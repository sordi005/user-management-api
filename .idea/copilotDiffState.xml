<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.InjectionStrategy;&#10;import org.mapstruct.Mapper;&#10;import org.mapstruct.Mapping;&#10;import org.mapstruct.ReportingPolicy;&#10;&#10;@Mapper(&#10;    componentModel = &quot;spring&quot;, &#10;    injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;    unmappedSourcePolicy = ReportingPolicy.ERROR&#10;)&#10;public class UserMapper {&#10;    &#10;    @Mapping({&#10;        @Mapping(target = &quot;password&quot;, ignore = true)&#10;        @Mapping(value = (target = &quot;fullname&quot;, expression = &quot;java(buildFullName(user,.getFirstName(), user.getLastName())&quot;)&quot;)&#10;    })&#10;    UserResponse toResponse(User user);&#10;    &#10;    @Mapping({&#10;            &#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;    &#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;    &#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.InjectionStrategy;&#10;import org.mapstruct.Mapper;&#10;import org.mapstruct.Mapping;&#10;import org.mapstruct.ReportingPolicy;&#10;&#10;@Mapper(&#10;    componentModel = &quot;spring&quot;, &#10;    injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;    unmappedSourcePolicy = ReportingPolicy.ERROR&#10;)&#10;public class UserMapper {&#10;    &#10;    @Mapping({&#10;        @Mapping(target = &quot;password&quot;, ignore = true)&#10;        @Mapping(value = (target = &quot;fullname&quot;, expression = &quot;java(buildFullName(user,.getFirstName(), user.getLastName())&quot;)&quot;)&#10;    })&#10;    UserResponse toResponse(User user);&#10;    &#10;    @Mapping({&#10;&#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;    &#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/ChangePasswordRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/ChangePasswordRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;public class ChangePasswordRequest {&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for changing user password.&#10; * Used when an authenticated user wants to change their password.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ChangePasswordRequest {&#10;    &#10;    @NotBlank(message = &quot;Current password is required&quot;)&#10;    private String currentPassword;&#10;    &#10;    @NotBlank(message = &quot;New password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String newPassword;&#10;    &#10;    @NotBlank(message = &quot;Password confirmation is required&quot;)&#10;    private String confirmPassword;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/JwtResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/JwtResponse.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonProperty;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * JWT authentication response following OAuth2 and industry standards.&#10; * Used after successful login or token refresh operations.&#10;&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class JwtResponse {&#10;&#10;    /**&#10;     * The JWT access token&#10;     */&#10;    @JsonProperty(&quot;access_token&quot;)&#10;    private String accessToken;&#10;&#10;    /**&#10;     * Token type (always &quot;Bearer&quot; for JWT)&#10;     */&#10;    @JsonProperty(&quot;token_type&quot;)&#10;    private String tokenType = &quot;Bearer&quot;;&#10;&#10;    /**&#10;     * Token expiration time in seconds&#10;     */&#10;    @JsonProperty(&quot;expires_in&quot;)&#10;    private long expiresIn;&#10;&#10;    /**&#10;     * Refresh token for obtaining new access tokens&#10;     */&#10;    @JsonProperty(&quot;refresh_token&quot;)&#10;    private String refreshToken;&#10;&#10;    /**&#10;     * Token scope/permissions (optional)&#10;     */&#10;    private String scope;&#10;&#10;    /**&#10;     * When the token was issued&#10;     */&#10;    @JsonProperty(&quot;issued_at&quot;)&#10;    private LocalDateTime issuedAt;&#10;&#10;    /**&#10;     * Constructor for basic JWT response&#10;     */&#10;    public JwtResponse(String accessToken, long expiresIn) {&#10;        this.accessToken = accessToken;&#10;        this.tokenType = &quot;Bearer&quot;;&#10;        this.expiresIn = expiresIn;&#10;        this.issuedAt = LocalDateTime.now();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonProperty;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Respuesta de autenticación JWT siguiendo estándares OAuth2 y de la industria.&#10; * Se usa después de operaciones exitosas de login o renovación de token.&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class JwtResponse {&#10;&#10;    /**&#10;     * El token de acceso JWT&#10;     */&#10;    @JsonProperty(&quot;access_token&quot;)&#10;    private String accessToken;&#10;&#10;    /**&#10;     * Tipo de token (siempre &quot;Bearer&quot; para JWT)&#10;     */&#10;    @JsonProperty(&quot;token_type&quot;)&#10;    private String tokenType = &quot;Bearer&quot;;&#10;&#10;    /**&#10;     * Tiempo de expiración del token en segundos&#10;     */&#10;    @JsonProperty(&quot;expires_in&quot;)&#10;    private long expiresIn;&#10;&#10;    /**&#10;     * Token de renovación para obtener nuevos tokens de acceso&#10;     */&#10;    @JsonProperty(&quot;refresh_token&quot;)&#10;    private String refreshToken;&#10;&#10;    /**&#10;     * Alcance/permisos del token (opcional)&#10;     */&#10;    private String scope;&#10;&#10;    /**&#10;     * Momento en que el token fue emitido&#10;     */&#10;    @JsonProperty(&quot;issued_at&quot;)&#10;    private LocalDateTime issuedAt;&#10;&#10;    /**&#10;     * Constructor para respuesta JWT básica&#10;     */&#10;    public JwtResponse(String accessToken, long expiresIn) {&#10;        this.accessToken = accessToken;&#10;        this.tokenType = &quot;Bearer&quot;;&#10;        this.expiresIn = expiresIn;&#10;        this.issuedAt = LocalDateTime.now();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/UserResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/UserResponse.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.response;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;public class UserResponse {&#10;    private Long id;&#10;&#10;    /**&#10;     * User's unique username&#10;     */&#10;    private String username;&#10;&#10;    /**&#10;     * User's email address&#10;    private String userName;&#10;    private String name;&#10;    private LocalDate birthDate;&#10;    private String dni;&#10;     * User's last name&#10;     */&#10;    private String lastName;&#10;&#10;    /**&#10;    private LocalDateTime onCreate;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.response;&#13;&#10;&#13;&#10;import com.fasterxml.jackson.annotation.JsonFormat;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;&#13;&#10;/**&#13;&#10; * DTO de respuesta para la entidad User.&#13;&#10; * Contiene solo información segura y pública sobre un usuario.&#13;&#10; * Nunca expone datos sensibles como contraseñas.&#13;&#10; *&#13;&#10; * @author Santiago Sordi&#13;&#10; * @version 1.0&#13;&#10; */&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class UserResponse {&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Identificador único del usuario&#13;&#10;     */&#13;&#10;    private Long id;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Nombre de usuario único&#13;&#10;     */&#13;&#10;    private String username;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Dirección de correo electrónico del usuario&#13;&#10;     */&#13;&#10;    private String email;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Nombre del usuario&#13;&#10;     */&#13;&#10;    private String firstName;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Apellido del usuario&#13;&#10;     */&#13;&#10;    private String lastName;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Nombre completo del usuario (campo calculado)&#13;&#10;     */&#13;&#10;    private String fullName;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Fecha de nacimiento del usuario&#13;&#10;     * Formateada como dd/MM/yyyy en las respuestas JSON&#13;&#10;     */&#13;&#10;    @JsonFormat(pattern = &quot;dd/MM/yyyy&quot;)&#13;&#10;    private LocalDate birthDate;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Fecha de creación de la cuenta&#13;&#10;     * Formateada como dd/MM/yyyy HH:mm:ss en las respuestas JSON&#13;&#10;     */&#13;&#10;    @JsonFormat(pattern = &quot;dd/MM/yyyy HH:mm:ss&quot;)&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Fecha de última actualización de la cuenta&#13;&#10;     * Formateada como dd/MM/yyyy HH:mm:ss en las respuestas JSON&#13;&#10;     */&#13;&#10;    @JsonFormat(pattern = &quot;dd/MM/yyyy HH:mm:ss&quot;)&#13;&#10;    private LocalDateTime updatedAt;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Indica si la cuenta del usuario está activa&#13;&#10;     */&#13;&#10;    private Boolean isActive;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Constructor personalizado para crear una respuesta básica de usuario&#13;&#10;     *&#13;&#10;     * @param id identificador único del usuario&#13;&#10;     * @param username nombre de usuario&#13;&#10;     * @param email correo electrónico&#13;&#10;     * @param firstName nombre&#13;&#10;     * @param lastName apellido&#13;&#10;     */&#13;&#10;    public UserResponse(Long id, String username, String email, String firstName, String lastName) {&#13;&#10;        this.id = id;&#13;&#10;        this.username = username;&#13;&#10;        this.email = email;&#13;&#10;        this.firstName = firstName;&#13;&#10;        this.lastName = lastName;&#13;&#10;        this.fullName = (firstName != null ? firstName : &quot;&quot;) + &quot; &quot; + (lastName != null ? lastName : &quot;&quot;);&#13;&#10;        this.isActive = true; // Por defecto activo&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calcula y retorna el nombre completo del usuario&#13;&#10;     * @return nombre completo concatenado&#13;&#10;     */&#13;&#10;    public String getFullName() {&#13;&#10;        if (fullName != null) {&#13;&#10;            return fullName;&#13;&#10;        }&#13;&#10;        return (firstName != null ? firstName : &quot;&quot;) + &quot; &quot; + (lastName != null ? lastName : &quot;&quot;);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtTokenProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtTokenProvider.java" />
              <option name="originalContent" value="package com.sordi.userManagement.security;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import io.jsonwebtoken.*;&#10;import io.jsonwebtoken.security.Keys;&#10;import jakarta.annotation.PostConstruct;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;/**&#10; * Proveedor de tokens JWT.&#10; * Maneja la creación, validación y extracción de información de tokens JWT.&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class JwtTokenProvider {&#10;    /**&#10;     * Configuración JWT inyectada desde JwtConfig&#10;     */&#10;    private final JwtConfig jwtConfig;&#10;&#10;    /**&#10;     * Clave secreta convertida a SecretKey para mayor seguridad.&#10;     * Se inicializa en el método init() usando la configuración de JwtConfig.&#10;     */&#10;    private SecretKey secretKey;&#10;    /**&#10;     * Inicializa la clave secreta después de la construcción del bean.&#10;     * Convierte la clave string en SecretKey para mayor seguridad criptográfica.&#10;     */&#10;    @PostConstruct&#10;    public void init() {&#10;        try {&#10;            // Convierte la clave string de JwtConfig en SecretKey segura&#10;            this.secretKey = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes());&#10;            log.info(&quot;JwtTokenProvider inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inicializando JwtTokenProvider: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error inicializando el proveedor de tokens JWT&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si un token JWT es válido y no ha expirado.&#10;     *&#10;     * @param token token JWT a validar&#10;     * @return true si el token es válido, false en caso contrario&#10;     */&#10;    public boolean validateToken(String token) {&#10;        if (token == null || token.trim().isEmpty()) {&#10;            log.warn(&quot;Intento de validación con token vacío&quot;);&#10;            return false;&#10;        }&#10;&#10;        try {&#10;            Jwts.parserBuilder()&#10;                    .setSigningKey(secretKey)&#10;                    .build()&#10;                    .parseClaimsJws(token);    // ← Valida automáticamente HS512&#10;&#10;            return true;&#10;&#10;        } catch (SecurityException e) {&#10;            log.warn(&quot;Token JWT con firma inválida: {}&quot;, e.getMessage());&#10;        } catch (MalformedJwtException e) {&#10;            log.warn(&quot;Token JWT malformado: {}&quot;, e.getMessage());&#10;        } catch (ExpiredJwtException e) {&#10;            log.warn(&quot;Token JWT expirado: {}&quot;, e.getMessage());&#10;        } catch (UnsupportedJwtException e) {&#10;            log.warn(&quot;Token JWT no soportado: {}&quot;, e.getMessage());&#10;        } catch (IllegalArgumentException e) {&#10;            log.warn(&quot;Token JWT con claims vacíos: {}&quot;, e.getMessage());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado validando token JWT: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return false;&#10;    }&#10;    /**&#10;     * Genera un token JWT para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el token&#10;     * @return token JWT firmado como String&#10;     */&#10;    public String generateToken(String username) {&#10;        // Validación de entrada&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new BusinessException(&quot;No se puede generar token sin username&quot;);&#10;        }&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateExpirationDate();&#10;&#10;            //Construir el token&#10;            return Jwts.builder()&#10;                    .setSubject(username)                    // &quot;sub&quot;: username&#10;                    .setIssuedAt(now)                       // &quot;iat&quot;: fecha actual&#10;                    .setExpiration(expiryDate)              // &quot;exp&quot;: fecha expiración&#10;                    .setIssuer(&quot;user-management-api&quot;)       // &quot;iss&quot;: emisor&#10;&#10;                    // SIGNATURE (firma digital)&#10;                    .signWith(secretKey, SignatureAlgorithm.HS512)  // Firma con clave secreta&#10;&#10;                    .compact();  // Convierte a string JWT final&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando token JWT para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new BusinessException(&quot;Error generando token de autenticación&quot;);&#10;        }&#10;    }&#10;    /**&#10;     * Extrae el username (subject) del token JWT.&#10;     * &#10;     * @param token token JWT válido&#10;     * @return username contenido en el token&#10;     * @throws BusinessException si el token es inválido o no contiene username&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        if (!validateToken(token)) {&#10;            throw new BusinessException(&quot;Token JWT inválido&quot;);&#10;        }&#10;        &#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .setSigningKey(secretKey)&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getBody();&#10;                &#10;            String username = claims.getSubject();&#10;            if (username == null || username.trim().isEmpty()) {&#10;                throw new BusinessException(&quot;Token JWT no contiene username válido&quot;);&#10;            }&#10;            &#10;            return username;&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error extrayendo username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera un refresh token para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el refresh token&#10;     * @return refresh token JWT firmado&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new BusinessException(&quot;No se puede generar refresh token sin username&quot;);&#10;        }&#10;&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateRefreshExpirationDate();&#10;&#10;            return Jwts.builder()&#10;                    .setSubject(username)&#10;                    .setIssuedAt(now)&#10;                    .setExpiration(expiryDate)&#10;                    .setIssuer(&quot;user-management-api&quot;)&#10;                    .claim(&quot;type&quot;, &quot;refresh&quot;) // Marca como refresh token&#10;                    .signWith(secretKey, SignatureAlgorithm.HS512)&#10;                    .compact();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando refresh token para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new BusinessException(&quot;Error generando refresh token&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la fecha de expiración del token.&#10;     * &#10;     * @param token token JWT válido&#10;     * @return fecha de expiración del token&#10;     */&#10;    public Date getExpirationDateFromToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parserBuilder()&#10;                .setSigningKey(secretKey)&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getBody();&#10;                &#10;            return claims.getExpiration();&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error obteniendo fecha de expiración del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si un token es de tipo refresh.&#10;     * &#10;     * @param token token JWT a verificar&#10;     * @return true si es refresh token, false en caso contrario&#10;     */&#10;    public boolean isRefreshToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parserBuilder()&#10;                .setSigningKey(secretKey)&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getBody();&#10;                &#10;            return &quot;refresh&quot;.equals(claims.get(&quot;type&quot;, String.class));&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verificando tipo de token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.security;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import io.jsonwebtoken.*;&#10;import io.jsonwebtoken.security.Keys;&#10;import jakarta.annotation.PostConstruct;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;/**&#10; * Proveedor de tokens JWT.&#10; * Maneja la creación, validación y extracción de información de tokens JWT.&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class JwtTokenProvider {&#10;    /**&#10;     * Configuración JWT inyectada desde JwtConfig&#10;     */&#10;    private final JwtConfig jwtConfig;&#10;&#10;    /**&#10;     * Clave secreta convertida a SecretKey para mayor seguridad.&#10;     * Se inicializa en el método init() usando la configuración de JwtConfig.&#10;     */&#10;    private SecretKey secretKey;&#10;    &#10;    /**&#10;     * Inicializa la clave secreta después de la construcción del bean.&#10;     * Convierte la clave string en SecretKey para mayor seguridad criptográfica.&#10;     */&#10;    @PostConstruct&#10;    public void init() {&#10;        try {&#10;            // Convierte la clave string de JwtConfig en SecretKey segura&#10;            this.secretKey = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes());&#10;            log.info(&quot;JwtTokenProvider inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inicializando JwtTokenProvider: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error inicializando el proveedor de tokens JWT&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si un token JWT es válido y no ha expirado.&#10;     *&#10;     * @param token token JWT a validar&#10;     * @return true si el token es válido, false en caso contrario&#10;     */&#10;    public boolean validateToken(String token) {&#10;        if (token == null || token.trim().isEmpty()) {&#10;            log.warn(&quot;Intento de validación con token vacío&quot;);&#10;            return false;&#10;        }&#10;&#10;        try {&#10;            // CAMBIO: parser() en lugar de parserBuilder() para JWT 0.12.x&#10;            Jwts.parser()&#10;                    .verifyWith(secretKey)  // Nueva sintaxis para verificar firma&#10;                    .build()&#10;                    .parseSignedClaims(token);  // Nuevo método para parsear&#10;&#10;            return true;&#10;&#10;        } catch (SecurityException e) {&#10;            log.warn(&quot;Token JWT con firma inválida: {}&quot;, e.getMessage());&#10;        } catch (MalformedJwtException e) {&#10;            log.warn(&quot;Token JWT malformado: {}&quot;, e.getMessage());&#10;        } catch (ExpiredJwtException e) {&#10;            log.warn(&quot;Token JWT expirado: {}&quot;, e.getMessage());&#10;        } catch (UnsupportedJwtException e) {&#10;            log.warn(&quot;Token JWT no soportado: {}&quot;, e.getMessage());&#10;        } catch (IllegalArgumentException e) {&#10;            log.warn(&quot;Token JWT con claims vacíos: {}&quot;, e.getMessage());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado validando token JWT: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Genera un token JWT para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el token&#10;     * @return token JWT firmado como String&#10;     */&#10;    public String generateToken(String username) {&#10;        // Validación de entrada&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new BusinessException(&quot;No se puede generar token sin username&quot;);&#10;        }&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateExpirationDate();&#10;&#10;            //Construir el token&#10;            return Jwts.builder()&#10;                    .subject(username)                      // &quot;sub&quot;: username&#10;                    .issuedAt(now)                         // &quot;iat&quot;: fecha actual&#10;                    .expiration(expiryDate)                // &quot;exp&quot;: fecha expiración&#10;                    .issuer(&quot;user-management-api&quot;)         // &quot;iss&quot;: emisor&#10;                    // SIGNATURE (firma digital)&#10;                    .signWith(secretKey)                   // Firma con clave secreta (algoritmo auto-detectado)&#10;                    .compact();  // Convierte a string JWT final&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando token JWT para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new BusinessException(&quot;Error generando token de autenticación&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Extrae el username (subject) del token JWT.&#10;     * &#10;     * @param token token JWT válido&#10;     * @return username contenido en el token&#10;     * @throws BusinessException si el token es inválido o no contiene username&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        if (!validateToken(token)) {&#10;            throw new BusinessException(&quot;Token JWT inválido&quot;);&#10;        }&#10;        &#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();  // getPayload() en lugar de getBody()&#10;                &#10;            String username = claims.getSubject();&#10;            if (username == null || username.trim().isEmpty()) {&#10;                throw new BusinessException(&quot;Token JWT no contiene username válido&quot;);&#10;            }&#10;            &#10;            return username;&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error extrayendo username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera un refresh token para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el refresh token&#10;     * @return refresh token JWT firmado&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new BusinessException(&quot;No se puede generar refresh token sin username&quot;);&#10;        }&#10;&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateRefreshExpirationDate();&#10;&#10;            return Jwts.builder()&#10;                    .subject(username)&#10;                    .issuedAt(now)&#10;                    .expiration(expiryDate)&#10;                    .issuer(&quot;user-management-api&quot;)&#10;                    .claim(&quot;type&quot;, &quot;refresh&quot;) // Marca como refresh token&#10;                    .signWith(secretKey)&#10;                    .compact();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando refresh token para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new BusinessException(&quot;Error generando refresh token&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la fecha de expiración del token.&#10;     * &#10;     * @param token token JWT válido&#10;     * @return fecha de expiración del token&#10;     */&#10;    public Date getExpirationDateFromToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;                &#10;            return claims.getExpiration();&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error obteniendo fecha de expiración del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si un token es de tipo refresh.&#10;     * &#10;     * @param token token JWT a verificar&#10;     * @return true si es refresh token, false en caso contrario&#10;     */&#10;    public boolean isRefreshToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;                &#10;            return &quot;refresh&quot;.equals(claims.get(&quot;type&quot;, String.class));&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verificando tipo de token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java" />
              <option name="originalContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j  // ← AGREGAR para logging&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;        &#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;            &#10;            User savedUser = userRepository.save(user);&#10;            &#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;, &#10;                    savedUser.getId(), savedUser.getUsername());&#10;            &#10;            return userMapper.toResponse(savedUser);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;, &#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;    &#10;    @Transactional&#10;    public UserResponse updateUser(Long id ,UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;        if (id == null || request == null) throw  new BusinessException(&quot;Ingrese el id  de usuario&quot;);&#10;        User userExisting = userRepository.findById(id)&#10;                .orElse(null);&#10;    } &#10;    &#10;    public UserResponse getUserById(Long id) {&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Usuario no encontrado&quot;));&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;    &#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j  // ← AGREGAR para logging&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;        &#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;            &#10;            User savedUser = userRepository.save(user);&#10;            &#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;, &#10;                    savedUser.getId(), savedUser.getUsername());&#10;            &#10;            return userMapper.toResponse(savedUser);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;, &#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;    &#10;    @Transactional&#10;    public UserResponse updateUser(Long id, UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;        &#10;        if (id == null || request == null) {&#10;            throw new BusinessException(&quot;ID de usuario y datos de actualización son requeridos&quot;);&#10;        }&#10;        &#10;        // Buscar usuario y lanzar excepción si no existe&#10;        User userExisting = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de actualizar usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;        &#10;        log.debug(&quot;Usuario encontrado para actualización: {}&quot;, userExisting.getUsername());&#10;        &#10;        // Validar email único si se está cambiando&#10;        if (request.getEmail() != null &amp;&amp; !request.getEmail().equals(userExisting.getEmail())) {&#10;            if (userRepository.existsByEmail(request.getEmail())) {&#10;                log.warn(&quot;Intento de actualizar con email duplicado: {}&quot;, request.getEmail());&#10;                throw new BusinessException(&quot;El email ya está en uso por otro usuario&quot;);&#10;            }&#10;        }&#10;        &#10;        // Actualizar usando mapper&#10;        userMapper.updateEntity(userExisting, request);&#10;        &#10;        // Guardar cambios&#10;        User savedUser = userRepository.save(userExisting);&#10;        &#10;        log.info(&quot;Usuario actualizado exitosamente con ID: {}&quot;, savedUser.getId());&#10;        &#10;        return userMapper.toResponse(savedUser);&#10;    }&#10;    &#10;    public UserResponse getUserById(Long id) {&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Usuario no encontrado&quot;));&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;    &#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>