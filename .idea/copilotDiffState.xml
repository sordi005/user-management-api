<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;&#9; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;3.5.4&lt;/version&gt;&#10;&#9;&#9;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.sordi&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;user-management-api&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;user-management-api&lt;/name&gt;&#10;&#9;&lt;description&gt;API REST para gestión de usuarios con autenticación JWT&lt;/description&gt;&#10;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;21&lt;/java.version&gt;&#10;&#9;&#9;&lt;jwt.version&gt;0.12.6&lt;/jwt.version&gt;&#10;&#9;&#9;&lt;springdoc.version&gt;2.7.0&lt;/springdoc.version&gt;&#10;&#9;&#9;&lt;mapstruct.version&gt;1.5.5.Final&lt;/mapstruct.version&gt;&#10;&#10;&#9;&lt;/properties&gt;&#10;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;!-- Spring Boot Starters --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT para autenticación --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Base de Datos --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Flyway para migraciones --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.flywaydb&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;flyway-core&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.flywaydb&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Documentación API --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springdoc&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${springdoc.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Desarrollo --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Testing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;!-- MapStruct --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${mapstruct.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;annotationProcessorPaths&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;version&gt;${lombok.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/annotationProcessorPaths&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;excludes&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/excludes&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;&#9; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;3.5.4&lt;/version&gt;&#10;&#9;&#9;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.sordi&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;user-management-api&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;user-management-api&lt;/name&gt;&#10;&#9;&lt;description&gt;API REST para gestión de usuarios con autenticación JWT&lt;/description&gt;&#10;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;21&lt;/java.version&gt;&#10;&#9;&#9;&lt;jwt.version&gt;0.12.6&lt;/jwt.version&gt;&#10;&#9;&#9;&lt;springdoc.version&gt;2.7.0&lt;/springdoc.version&gt;&#10;&#9;&#9;&lt;mapstruct.version&gt;1.5.5.Final&lt;/mapstruct.version&gt;&#10;&#10;&#9;&lt;/properties&gt;&#10;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;!-- Spring Boot Starters --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT para autenticación --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${jwt.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Base de Datos --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Flyway para migraciones --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.flywaydb&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;flyway-core&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.flywaydb&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Documentación API --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springdoc&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${springdoc.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Desarrollo --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Testing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;!-- MapStruct --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;${mapstruct.version}&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;annotationProcessorPaths&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;version&gt;${lombok.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;!-- MapStruct annotation processor --&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;version&gt;${mapstruct.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;!-- Lombok-MapStruct binding for compatibility --&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;version&gt;0.2.0&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/path&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/annotationProcessorPaths&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;excludes&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/excludes&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.core.userdetails.UsernameNotFoundException;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;&#10;/**&#10; * Configuración de seguridad para la aplicación.&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    // Dependencias necesarias para la configuración de seguridad&#10;    private final UserRepository userRepository;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    /**&#10;     * Bean para el codificador de contraseñas.&#10;     */&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    /**&#10;     * Bean de UserDetailsService personalizado.&#10;     * Le dice a Spring Security cómo cargar usuarios desde la base de datos.&#10;     */&#10;    @Bean&#10;    public UserDetailsService userDetailsService() {&#10;        return username -&gt; {&#10;            // Buscar usuario en la base de datos&#10;            User user = userRepository.findByUsername(username)&#10;                .orElseThrow(() -&gt; new UsernameNotFoundException(&#10;                    &quot;Usuario no encontrado: &quot; + username));&#10;            // UserDetails es la interfaz que Spring Security entiende&#10;            return org.springframework.security.core.userdetails.User.builder()&#10;                .username(user.getUsername())&#10;                .password(user.getPassword()) // Ya viene encriptada de la BD&#10;                .authorities(&quot;USER&quot;)&#10;                .accountExpired(false) // No expirado&#10;                .accountLocked(false) // No bloqueado&#10;                .credentialsExpired(false) // Credenciales no expiradas&#10;                .disabled(false) // No deshabilitado&#10;                .build();&#10;        };&#10;    }&#10;    /**&#10;        * Bean para el AuthenticationManager.&#10;     */&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(&#10;            AuthenticationConfiguration authConfig) throws Exception {&#10;        return authConfig.getAuthenticationManager();&#10;    }&#10;&#10;    /**&#10;     * Bean de SecurityFilterChain - Define las reglas de seguridad de la aplicación.&#10;     *&#10;     * ¿Qué hace?&#10;     * - Define qué endpoints son públicos (sin autenticación)&#10;     * - Define qué endpoints requieren autenticación&#10;     * - Configura políticas de sesión (stateless para JWT)&#10;     * - Deshabilita CSRF (no necesario para APIs REST)&#10;     * - Configura CORS para frontend&#10;     */&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            // Deshabilitar Cross-Site Request Forgery (CSRF)&#10;            .csrf(csrf -&gt; csrf.disable())&#10;&#10;            // Configurar sesiones como STATELESS (para JWT)&#10;            // No guardamos estado en el servidor&#10;            .sessionManagement(session -&gt;&#10;                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;&#10;            // Configurar qué endpoints requieren autenticación&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                // ENDPOINTS PÚBLICOS (sin autenticación)&#10;                .requestMatchers(&quot;/api/v1/auth/**&quot;).permitAll()        // Login, register&#10;                .requestMatchers(&quot;/h2-console/**&quot;).permitAll()         // Base de datos H2 - solo desarrollo&#10;&#10;                // ENDPOINTS OPCIONALES&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;).permitAll()         //  Documentación Swagger&#10;                //.requestMatchers(&quot;/v3/api-docs/**&quot;).permitAll()        //  Datos para Swagger&#10;                //.requestMatchers(&quot;/actuator/**&quot;).permitAll()           //  Monitoreo de aplicación&#10;&#10;                // ENDPOINTS PRIVADOS (requieren autenticación)&#10;                .anyRequest().authenticated()&#10;            )&#10;&#10;            // Configurar el filtro de autenticación JWT&#10;            .addFilterBefore(jwtTokenProvider(), UsernamePasswordAuthenticationFilter.class)&#10;&#10;            // Configurar headers para H2 console (solo desarrollo)&#10;            // H2 usa frames y Spring Security los bloquea por defecto&#10;            .headers(headers -&gt; headers.frameOptions().disable());&#10;&#10;        return http.build();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.CustomUserDetailsService;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;&#10;/**&#10; * Configuración de seguridad para la aplicación.&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    // Dependencias necesarias para la configuración de seguridad&#10;    private final CustomUserDetailsService customUserDetailsService;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    /**&#10;     * Bean para el codificador de contraseñas.&#10;     */&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    /**&#10;     * Bean para el AuthenticationManager.&#10;     */&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(&#10;            AuthenticationConfiguration authConfig) throws Exception {&#10;        return authConfig.getAuthenticationManager();&#10;    }&#10;&#10;    /**&#10;     * Bean de SecurityFilterChain - Define las reglas de seguridad de la aplicación.&#10;     *&#10;     * ¿Qué hace?&#10;     * - Define qué endpoints son públicos (sin autenticación)&#10;     * - Define qué endpoints requieren autenticación&#10;     * - Configura políticas de sesión (stateless para JWT)&#10;     * - Deshabilita CSRF (no necesario para APIs REST)&#10;     * - Configura CORS para frontend&#10;     */&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            // Deshabilitar Cross-Site Request Forgery (CSRF)&#10;            .csrf(csrf -&gt; csrf.disable())&#10;&#10;            // Configurar sesiones como STATELESS (para JWT)&#10;            // No guardamos estado en el servidor&#10;            .sessionManagement(session -&gt;&#10;                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;&#10;            // Configurar qué endpoints requieren autenticación&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                // ENDPOINTS PÚBLICOS (sin autenticación)&#10;                .requestMatchers(&quot;/api/v1/auth/**&quot;).permitAll()        // Login, register&#10;                .requestMatchers(&quot;/h2-console/**&quot;).permitAll()         // Base de datos H2 - solo desarrollo&#10;&#10;                // ENDPOINTS OPCIONALES&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;).permitAll()         //  Documentación Swagger&#10;                //.requestMatchers(&quot;/v3/api-docs/**&quot;).permitAll()        //  Datos para Swagger&#10;                //.requestMatchers(&quot;/actuator/**&quot;).permitAll()           //  Monitoreo de aplicación&#10;&#10;                // ENDPOINTS PRIVADOS (requieren autenticación)&#10;                .anyRequest().authenticated()&#10;            )&#10;&#10;            // Configurar headers para H2 console (solo desarrollo)&#10;            // H2 usa frames y Spring Security los bloquea por defecto&#10;            .headers(headers -&gt; headers.frameOptions().disable());&#10;&#10;        return http.build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.*;&#10;&#10;import java.util.List;&#10;&#10;@Mapper(&#10;        componentModel = &quot;spring&quot;,&#10;        injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;        unmappedSourcePolicy = ReportingPolicy.ERROR&#10;)&#10;public interface UserMapper {&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;fullName&quot;, expression =&quot;java(buildFullName(user.getFirstName(), user.getLastName()))&quot;),&#10;    })&#10;    UserResponse toResponse(User user);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true), // Este campo se maneja automáticamente&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true)&#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;dni&quot;, ignore = true), // DNI no se puede actualizar&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;username&quot;, ignore = true),&#10;            @Mapping(target = &quot;password&quot;, ignore = true)&#10;    })&#10;    void updateEntity(@MappingTarget User user , UpdateUserRequest request);&#10;&#10;    List&lt;UserResponse&gt; toResponseList(List&lt;User&gt;users) ;&#10;&#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.*;&#10;&#10;import java.util.List;&#10;&#10;@Mapper(&#10;        componentModel = &quot;spring&quot;,&#10;        injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;        unmappedSourcePolicy = ReportingPolicy.IGNORE&#10;)&#10;public interface UserMapper {&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;fullName&quot;, expression =&quot;java(buildFullName(user.getFirstName(), user.getLastName()))&quot;),&#10;    })&#10;    UserResponse toResponse(User user);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true), // Este campo se maneja automáticamente&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true)&#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;dni&quot;, ignore = true), // DNI no se puede actualizar&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;username&quot;, ignore = true),&#10;            @Mapping(target = &quot;password&quot;, ignore = true)&#10;    })&#10;    void updateEntity(@MappingTarget User user , UpdateUserRequest request);&#10;&#10;    List&lt;UserResponse&gt; toResponseList(List&lt;User&gt;users) ;&#10;&#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10; * DTO para actualización de usuario por parte del administrador.&#10; * Incluye campos que solo admin puede modificar como isActive.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Schema(description = &quot;Request para actualización de usuario por administrador&quot;)&#10;public class AdminUpdateUserRequest {&#10;&#10;    @Schema(description = &quot;Nombre del usuario&quot;, example = &quot;Juan&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El nombre debe tener entre 2 y 50 caracteres&quot;)&#10;    private String firstName;&#10;&#10;    @Schema(description = &quot;Apellido del usuario&quot;, example = &quot;Pérez&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El apellido debe tener entre 2 y 50 caracteres&quot;)&#10;    private String lastName;&#10;&#10;    @Schema(description = &quot;Email del usuario&quot;, example = &quot;juan.perez@email.com&quot;)&#10;    @Email(message = &quot;Formato de email inválido&quot;)&#10;    private String email;&#10;&#10;    @Schema(description = &quot;Estado activo del usuario&quot;, example = &quot;true&quot;)&#10;    private Boolean isActive; // ✅ Solo admin puede cambiar esto&#10;&#10;    @Schema(description = &quot;Rol del usuario&quot;, example = &quot;USER&quot;)&#10;    private String role; // ✅ Solo admin puede cambiar roles&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/CustomUserDetailsService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/CustomUserDetailsService.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.security;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.core.userdetails.UsernameNotFoundException;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Servicio personalizado para cargar detalles de usuario para Spring Security.&#10; * &#10; * Esta clase implementa UserDetailsService y es utilizada por Spring Security&#10; * para cargar información del usuario durante la autenticación.&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class CustomUserDetailsService implements UserDetailsService {&#10;    &#10;    private final UserRepository userRepository;&#10;    &#10;    /**&#10;     * Carga un usuario por su nombre de usuario para Spring Security.&#10;     * &#10;     * @param username el nombre de usuario a buscar&#10;     * @return UserDetails objeto que Spring Security puede usar para autenticación&#10;     * @throws UsernameNotFoundException si el usuario no existe&#10;     */&#10;    @Override&#10;    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {&#10;        log.debug(&quot;Cargando usuario para autenticación: {}&quot;, username);&#10;        &#10;        // Buscar usuario en la base de datos&#10;        User user = userRepository.findByUsername(username)&#10;            .orElseThrow(() -&gt; {&#10;                log.warn(&quot;Intento de login con usuario inexistente: {}&quot;, username);&#10;                return new UsernameNotFoundException(&quot;Usuario no encontrado: &quot; + username);&#10;            });&#10;        &#10;        log.debug(&quot;Usuario encontrado: {}&quot;, username);&#10;        &#10;        // Convertir nuestra entidad User a UserDetails que Spring Security entiende&#10;        return org.springframework.security.core.userdetails.User.builder()&#10;            .username(user.getUsername())&#10;            .password(user.getPassword()) // Ya viene encriptada de la BD&#10;            .authorities(&quot;ROLE_USER&quot;) // Roles del usuario (puedes expandir esto)&#10;            .accountExpired(false) // La cuenta no está expirada&#10;            .accountLocked(false) // La cuenta no está bloqueada&#10;            .credentialsExpired(false) // Las credenciales no están expiradas&#10;            .disabled(false) // La cuenta no está deshabilitada&#10;            .build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtAuthenticationFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtAuthenticationFilter.java" />
              <option name="originalContent" value="package com.sordi.userManagement.security;&#10;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;    &#10;    private JwtTokenProvider jwtTokenProvider;&#10;        &#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.security;&#10;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Filtro de autenticación JWT que intercepta todas las peticiones HTTP.&#10; * &#10; * Este filtro se ejecuta ANTES de que la petición llegue al controlador.&#10; * Su función es extraer y validar el token JWT, y si es válido,&#10; * establecer la autenticación en Spring Security.&#10; */&#10;@Slf4j&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;    &#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final UserDetailsService userDetailsService;&#10;    &#10;    /**&#10;     * Constructor que recibe las dependencias necesarias.&#10;     * Este constructor es llamado desde SecurityConfig.&#10;     */&#10;    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider, UserDetailsService userDetailsService) {&#10;        this.jwtTokenProvider = jwtTokenProvider;&#10;        this.userDetailsService = userDetailsService;&#10;    }&#10;    &#10;    /**&#10;     * Método principal del filtro que se ejecuta en cada petición HTTP.&#10;     * &#10;     * @param request petición HTTP entrante&#10;     * @param response respuesta HTTP&#10;     * @param filterChain cadena de filtros de Spring Security&#10;     */&#10;    @Override&#10;    protected void doFilterInternal(&#10;            HttpServletRequest request,&#10;            HttpServletResponse response,&#10;            FilterChain filterChain) throws ServletException, IOException {&#10;        &#10;        try {&#10;            // 1. Extraer el token JWT del header Authorization&#10;            String jwt = extractTokenFromRequest(request);&#10;            &#10;            // 2. Si hay token y es válido, autenticar al usuario&#10;            if (jwt != null &amp;&amp; jwtTokenProvider.validateToken(jwt)) {&#10;                // 3. Obtener el username del token&#10;                String username = jwtTokenProvider.getUsernameFromToken(jwt);&#10;                &#10;                // 4. Cargar los detalles del usuario&#10;                UserDetails userDetails = userDetailsService.loadUserByUsername(username);&#10;                &#10;                // 5. Crear el objeto de autenticación&#10;                UsernamePasswordAuthenticationToken authentication = &#10;                    new UsernamePasswordAuthenticationToken(&#10;                        userDetails,&#10;                        null,&#10;                        userDetails.getAuthorities()&#10;                    );&#10;                &#10;                // 6. Establecer detalles adicionales de la petición&#10;                authentication.setDetails(&#10;                    new WebAuthenticationDetailsSource().buildDetails(request)&#10;                );&#10;                &#10;                // 7. Establecer la autenticación en Spring Security&#10;                SecurityContextHolder.getContext().setAuthentication(authentication);&#10;                &#10;                log.debug(&quot;Usuario autenticado: {}&quot;, username);&#10;            }&#10;            &#10;        } catch (Exception ex) {&#10;            // Si hay cualquier error, simplemente log y continuar sin autenticar&#10;            log.error(&quot;Error al procesar token JWT: {}&quot;, ex.getMessage());&#10;            SecurityContextHolder.clearContext();&#10;        }&#10;        &#10;        // 8. SIEMPRE continuar con la cadena de filtros&#10;        filterChain.doFilter(request, response);&#10;    }&#10;    &#10;    /**&#10;     * Extrae el token JWT del header Authorization.&#10;     * &#10;     * @param request petición HTTP&#10;     * @return token JWT sin el prefijo &quot;Bearer &quot;, o null si no existe&#10;     */&#10;    private String extractTokenFromRequest(HttpServletRequest request) {&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        &#10;        // Verificar si el header existe y tiene el formato correcto&#10;        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            // Extraer solo el token, sin el prefijo &quot;Bearer &quot;&#10;            return bearerToken.substring(7);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtTokenProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/security/JwtTokenProvider.java" />
              <option name="originalContent" value="package com.sordi.userManagement.security;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import io.jsonwebtoken.*;&#10;import io.jsonwebtoken.security.Keys;&#10;import jakarta.annotation.PostConstruct;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;/**&#10; * Proveedor de tokens JWT.&#10; * Maneja la creación, validación y extracción de información de tokens JWT.&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class JwtTokenProvider {&#10;    /**&#10;     * Configuración JWT inyectada desde JwtConfig&#10;     */&#10;    private final JwtConfig jwtConfig;&#10;&#10;    /**&#10;     * Clave secreta convertida a SecretKey para mayor seguridad.&#10;     * Se inicializa en el método init() usando la configuración de JwtConfig.&#10;     */&#10;    private SecretKey secretKey;&#10;&#10;    /**&#10;     * Inicializa la clave secreta después de la construcción del bean.&#10;     * Convierte la clave string en SecretKey para mayor seguridad criptográfica.&#10;     */&#10;    @PostConstruct&#10;    public void init() {&#10;        try {&#10;            // Convierte la clave string de JwtConfig en SecretKey segura&#10;            this.secretKey = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes());&#10;            log.info(&quot;JwtTokenProvider inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inicializando JwtTokenProvider: {}&quot;, e.getMessage());&#10;            throw new IllegalArgumentException(&quot;Error inicializando el proveedor de tokens JWT&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si un token JWT es válido y no ha expirado.&#10;     *&#10;     * @param token token JWT a validar&#10;     * @return true si el token es válido, false en caso contrario&#10;     */&#10;    public boolean validateToken(String token) {&#10;        if (token == null || token.trim().isEmpty()) {&#10;            log.warn(&quot;Intento de validación con token vacío&quot;);&#10;            return false;&#10;        }&#10;&#10;        try {&#10;            Jwts.parser()&#10;                    .verifyWith(secretKey)&#10;                    .build()&#10;                    .parseSignedClaims(token);&#10;&#10;            return true;&#10;&#10;        } catch (SecurityException e) {&#10;            log.warn(&quot;Token JWT con firma inválida: {}&quot;, e.getMessage());&#10;        } catch (MalformedJwtException e) {&#10;            log.warn(&quot;Token JWT malformado: {}&quot;, e.getMessage());&#10;        } catch (ExpiredJwtException e) {&#10;            log.warn(&quot;Token JWT expirado: {}&quot;, e.getMessage());&#10;        } catch (UnsupportedJwtException e) {&#10;            log.warn(&quot;Token JWT no soportado: {}&quot;, e.getMessage());&#10;        } catch (IllegalArgumentException e) {&#10;            log.warn(&quot;Token JWT con claims vacíos: {}&quot;, e.getMessage());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado validando token JWT: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Genera un token JWT para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el token&#10;     * @return token JWT firmado como String&#10;     */&#10;    public String generateToken(String username) {&#10;        // Validación de entrada&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No se puede generar token sin username&quot;);&#10;        }&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateExpirationDate();&#10;&#10;            //Construir el token&#10;            return Jwts.builder()&#10;                    .subject(username)                      // &quot;sub&quot;: username&#10;                    .issuedAt(now)                         // &quot;iat&quot;: fecha actual&#10;                    .expiration(expiryDate)                // &quot;exp&quot;: fecha expiración&#10;                    .issuer(&quot;user-management-api&quot;)         // &quot;iss&quot;: emisor&#10;                    // SIGNATURE (firma digital)&#10;                    .signWith(secretKey)&#10;                    .compact();  // Convierte a string JWT final&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando token JWT para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new RuntimeException(&quot;Error generando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae el username del token JWT.&#10;     *&#10;     * @param token token JWT válido&#10;     * @return username contenido en el token&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        if (!validateToken(token)) {&#10;            throw new BusinessException(&quot;Token JWT inválido&quot;);&#10;        }&#10;&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();  // Obtiene los claims del token(UserName, issuedAt, expiration, etc.)&#10;&#10;            String username = claims.getSubject();&#10;            if (username == null || username.trim().isEmpty()) {&#10;                throw new BusinessException(&quot;Token JWT no contiene username válido&quot;);&#10;            }&#10;&#10;            return username;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error extrayendo username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera un refresh token para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el refresh token&#10;     * @return refresh token JWT firmado&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new BusinessException(&quot;No se puede generar refresh token sin username&quot;);&#10;        }&#10;&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateRefreshExpirationDate();&#10;&#10;            return Jwts.builder()&#10;                    .subject(username)&#10;                    .issuedAt(now)&#10;                    .expiration(expiryDate)&#10;                    .issuer(&quot;user-management-api&quot;)&#10;                    .claim(&quot;type&quot;, &quot;refresh&quot;) // Marca como refresh token&#10;                    .signWith(secretKey)&#10;                    .compact();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando refresh token para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new BusinessException(&quot;Error generando refresh token&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la fecha de expiración del token.&#10;     *&#10;     * @param token token JWT válido&#10;     * @return fecha de expiración del token&#10;     */&#10;    public Date getExpirationDateFromToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;&#10;            return claims.getExpiration();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error obteniendo fecha de expiración del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si un token es de tipo refresh.&#10;     *&#10;     * @param token token JWT a verificar&#10;     * @return true si es refresh token, false en caso contrario&#10;     */&#10;    public boolean isRefreshToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;&#10;            return &quot;refresh&quot;.equals(claims.get(&quot;type&quot;, String.class));&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verificando tipo de token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.security;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import io.jsonwebtoken.*;&#10;import io.jsonwebtoken.security.Keys;&#10;import jakarta.annotation.PostConstruct;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;/**&#10; * Proveedor de tokens JWT.&#10; * Maneja la creación, validación y extracción de información de tokens JWT.&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class JwtTokenProvider {&#10;    /**&#10;     * Configuración JWT inyectada desde JwtConfig&#10;     */&#10;    private final JwtConfig jwtConfig;&#10;&#10;    /**&#10;     * Clave secreta convertida a SecretKey para mayor seguridad.&#10;     * Se inicializa en el método init() usando la configuración de JwtConfig.&#10;     */&#10;    private SecretKey secretKey;&#10;&#10;    /**&#10;     * Inicializa la clave secreta después de la construcción del bean.&#10;     * Convierte la clave string en SecretKey para mayor seguridad criptográfica.&#10;     */&#10;    @PostConstruct&#10;    public void init() {&#10;        try {&#10;            // Convierte la clave string de JwtConfig en SecretKey segura&#10;            this.secretKey = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes());&#10;            log.info(&quot;JwtTokenProvider inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inicializando JwtTokenProvider: {}&quot;, e.getMessage());&#10;            throw new IllegalArgumentException(&quot;Error inicializando el proveedor de tokens JWT&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si un token JWT es válido y no ha expirado.&#10;     *&#10;     * @param token token JWT a validar&#10;     * @return true si el token es válido, false en caso contrario&#10;     */&#10;    public boolean validateToken(String token) {&#10;        if (token == null || token.trim().isEmpty()) {&#10;            log.warn(&quot;Intento de validación con token vacío&quot;);&#10;            return false;&#10;        }&#10;&#10;        try {&#10;            Jwts.parser()&#10;                    .verifyWith(secretKey)&#10;                    .build()&#10;                    .parseSignedClaims(token);&#10;&#10;            return true;&#10;&#10;        } catch (SecurityException e) {&#10;            log.warn(&quot;Token JWT con firma inválida: {}&quot;, e.getMessage());&#10;        } catch (MalformedJwtException e) {&#10;            log.warn(&quot;Token JWT malformado: {}&quot;, e.getMessage());&#10;        } catch (ExpiredJwtException e) {&#10;            log.warn(&quot;Token JWT expirado: {}&quot;, e.getMessage());&#10;        } catch (UnsupportedJwtException e) {&#10;            log.warn(&quot;Token JWT no soportado: {}&quot;, e.getMessage());&#10;        } catch (IllegalArgumentException e) {&#10;            log.warn(&quot;Token JWT con claims vacíos: {}&quot;, e.getMessage());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado validando token JWT: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Genera un token JWT para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el token&#10;     * @return token JWT firmado como String&#10;     */&#10;    public String generateToken(String username) {&#10;        // Validación de entrada&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No se puede generar token sin username&quot;);&#10;        }&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateExpirationDate();&#10;&#10;            //Construir el token&#10;            return Jwts.builder()&#10;                    .subject(username)                      // &quot;sub&quot;: username&#10;                    .issuedAt(now)                         // &quot;iat&quot;: fecha actual&#10;                    .expiration(expiryDate)                // &quot;exp&quot;: fecha expiración&#10;                    .issuer(&quot;user-management-api&quot;)         // &quot;iss&quot;: emisor&#10;                    // SIGNATURE (firma digital)&#10;                    .signWith(secretKey)&#10;                    .compact();  // Convierte a string JWT final&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando token JWT para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new RuntimeException(&quot;Error generando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae el username del token JWT.&#10;     *&#10;     * @param token token JWT válido&#10;     * @return username contenido en el token&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        if (!validateToken(token)) {&#10;            throw new BusinessException(&quot;Token JWT inválido&quot;);&#10;        }&#10;&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();  // Obtiene los claims del token(UserName, issuedAt, expiration, etc.)&#10;&#10;            String username = claims.getSubject();&#10;            if (username == null || username.trim().isEmpty()) {&#10;                throw new BusinessException(&quot;Token JWT no contiene username válido&quot;);&#10;            }&#10;&#10;            return username;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error extrayendo username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera un refresh token para el usuario especificado.&#10;     *&#10;     * @param username nombre de usuario para incluir en el refresh token&#10;     * @return refresh token JWT firmado&#10;     */&#10;    public String generateRefreshToken(String username) {&#10;        if (username == null || username.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No se puede generar refresh token sin username&quot;);&#10;        }&#10;&#10;        try {&#10;            Date now = new Date();&#10;            Date expiryDate = jwtConfig.calculateRefreshExpirationDate();&#10;&#10;            return Jwts.builder()&#10;                    .subject(username)&#10;                    .issuedAt(now)&#10;                    .expiration(expiryDate)&#10;                    .issuer(&quot;user-management-api&quot;)&#10;                    .claim(&quot;type&quot;, &quot;refresh&quot;) // Marca como refresh token&#10;                    .signWith(secretKey)&#10;                    .compact();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando refresh token para usuario {}: {}&quot;, username, e.getMessage());&#10;            throw new RuntimeException(&quot;Error generando refresh token&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la fecha de expiración del token.&#10;     *&#10;     * @param token token JWT válido&#10;     * @return fecha de expiración del token&#10;     */&#10;    public Date getExpirationDateFromToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;&#10;            return claims.getExpiration();&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error obteniendo fecha de expiración del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Error procesando token de autenticación&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si un token es de tipo refresh.&#10;     *&#10;     * @param token token JWT a verificar&#10;     * @return true si es refresh token, false en caso contrario&#10;     */&#10;    public boolean isRefreshToken(String token) {&#10;        try {&#10;            Claims claims = Jwts.parser()&#10;                .verifyWith(secretKey)&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;&#10;            return &quot;refresh&quot;.equals(claims.get(&quot;type&quot;, String.class));&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error verificando tipo de token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java" />
              <option name="originalContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Servicio para gestión de usuarios&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    /**&#10;     * Crear un nuevo usuario&#10;     * @param request datos del usuario a crear&#10;     * @return Respuesta con los datos del usuario creado&#10;     */&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;&#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;&#10;            User savedUser = userRepository.save(user);&#10;&#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;,&#10;                    savedUser.getId(), savedUser.getUsername());&#10;&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;,&#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;    /**&#10;     * Actualizar un usuario existente&#10;     * @param id ID del usuario a actualizar&#10;     * @param request datos de actualización&#10;     * @return usuario actualizado&#10;     */&#10;&#10;    @Transactional&#10;    public UserResponse updateUser(Long id, UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;&#10;        if (id == null || request == null) {&#10;            throw new IllegalArgumentException(&quot;ID de usuario y datos de actualización son requeridos&quot;);&#10;        }&#10;&#10;        // Buscar usuario y lanzar excepción si no existe&#10;        User userExisting = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de actualizar usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        log.debug(&quot;Usuario encontrado para actualización: {}&quot;, userExisting.getUsername());&#10;&#10;        // Validar email único si se está cambiando&#10;        if (request.getEmail() != null &amp;&amp; !request.getEmail().equals(userExisting.getEmail())) {&#10;            if (userRepository.existsByEmail(request.getEmail())) {&#10;                log.warn(&quot;Intento de actualizar con email duplicado: {}&quot;, request.getEmail());&#10;                throw new BusinessException(&quot;El email ya está en uso por otro usuario&quot;);&#10;            }&#10;        }&#10;        try {&#10;            // Actualizar usando mapper&#10;            userMapper.updateEntity(userExisting, request);&#10;&#10;            // Guardar cambios&#10;            User savedUser = userRepository.save(userExisting);&#10;            log.info(&quot;Usuario actualizado exitosamente con ID: {}&quot;, savedUser.getId());&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al actualizar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw  new RuntimeException(&quot;Error interno al actualizar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Eliminar un usuario por ID&#10;     * @param id ID del usuario a eliminar&#10;     */&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        log.info(&quot;Iniciando eliminación de usuario con ID: {}&quot;, id);&#10;        if (id == null) throw new BusinessException(&quot;ID de usuario es requerido para eliminar&quot;);&#10;        if (!userRepository.existsById(id)) {&#10;            log.warn(&quot;Intento de eliminar usuario inexistente con ID: {}&quot;, id);&#10;            throw new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;        }&#10;        log.debug(&quot;Usuario encontrado para eliminación ID: {}&quot;, id);&#10;        try{&#10;            userRepository.deleteById(id);&#10;            log.info(&quot;Usuario eliminado exitosamente con ID: {}&quot;, id);&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al eliminar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al eliminar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtener un usuario por ID&#10;     * @param id ID del usuario a buscar&#10;     * @return DTO de respuesta con los datos del usuario&#10;     */&#10;    public UserResponse getUserById(Long id) {&#10;        log.info(&quot;Iniciando obtención de usuario con ID: {}&quot;, id);&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de obtener usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;&#10;    /**&#10;     * Obtener todos los usuarios con paginación básica&#10;     * @param page número de página (inicia en 0)&#10;     * @param size cantidad de usuarios por página&#10;     * @return página de usuarios&#10;     */&#10;    public Page&lt;UserResponse&gt; getAllUsers(int page, int size) {&#10;        log.info(&quot;Obteniendo usuarios - Página: {}, Tamaño: {}&quot;, page, size);&#10;        if (page &lt;= 0 || size &lt;= 0)  {&#10;            log.warn(&quot;Parámetros de paginación inválidos - Página: {}, Tamaño: {}&quot;, page, size);&#10;            throw new BusinessException(&quot;Parámetros de paginación inválidos&quot;);&#10;        }&#10;        try {&#10;            // Crear paginación ordenada por ID&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;id&quot;));&#10;&#10;            // Obtener página de usuarios de la BD&#10;            Page&lt;User&gt; userPage = userRepository.findAll(pageable);&#10;&#10;            log.info(&quot;Se encontraron {} usuarios en página {} de {}&quot;,&#10;                    userPage.getContent().size(), page, userPage.getTotalPages());&#10;&#10;            // Convertir a DTOs y retornar&#10;            return userPage.map(userMapper::toResponse);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al obtener usuarios: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al obtener usuarios&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Buscar usuarios por nombre con paginación&#10;     * @param firstName nombre a buscar&#10;     * @param page número de página&#10;     * @param size tamaño de página&#10;     * @return página de usuarios que coincidan&#10;     */&#10;    public Page&lt;UserResponse&gt; searchUsersByName(String firstName, int page, int size) {&#10;        log.info(&quot;Buscando usuarios por nombre: '{}' - Página: {}, Tamaño: {}&quot;, firstName, page, size);&#10;&#10;        try {&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;firstName&quot;));&#10;            Page&lt;User&gt; userPage = userRepository.findByFirstNameContainingIgnoreCase(firstName, pageable);&#10;&#10;            log.info(&quot;Se encontraron {} usuarios con nombre: '{}'&quot;, userPage.getContent().size(), firstName);&#10;            return userPage.map(userMapper::toResponse);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error en búsqueda por nombre: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno en búsqueda&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Servicio para gestión de usuarios&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    /**&#10;     * Crear un nuevo usuario&#10;     * @param request datos del usuario a crear&#10;     * @return Respuesta con los datos del usuario creado&#10;     */&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;&#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;&#10;            User savedUser = userRepository.save(user);&#10;&#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;,&#10;                    savedUser.getId(), savedUser.getUsername());&#10;&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;,&#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;    /**&#10;     * Actualizar un usuario existente&#10;     * @param id ID del usuario a actualizar&#10;     * @param request datos de actualización&#10;     * @return usuario actualizado&#10;     */&#10;&#10;    @Transactional&#10;    public UserResponse updateUser(Long id, UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;&#10;        if (id == null || request == null) {&#10;            throw new IllegalArgumentException(&quot;ID de usuario y datos de actualización son requeridos&quot;);&#10;        }&#10;&#10;        // Buscar usuario y lanzar excepción si no existe&#10;        User userExisting = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de actualizar usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        log.debug(&quot;Usuario encontrado para actualización: {}&quot;, userExisting.getUsername());&#10;&#10;        // Validar email único si se está cambiando&#10;        if (request.getEmail() != null &amp;&amp; !request.getEmail().equals(userExisting.getEmail())) {&#10;            if (userRepository.existsByEmail(request.getEmail())) {&#10;                log.warn(&quot;Intento de actualizar con email duplicado: {}&quot;, request.getEmail());&#10;                throw new BusinessException(&quot;El email ya está en uso por otro usuario&quot;);&#10;            }&#10;        }&#10;        try {&#10;            // Actualizar usando mapper&#10;            userMapper.updateEntity(userExisting, request);&#10;&#10;            // Guardar cambios&#10;            User savedUser = userRepository.save(userExisting);&#10;            log.info(&quot;Usuario actualizado exitosamente con ID: {}&quot;, savedUser.getId());&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al actualizar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw  new RuntimeException(&quot;Error interno al actualizar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Eliminar un usuario por ID&#10;     * @param id ID del usuario a eliminar&#10;     */&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        log.info(&quot;Iniciando eliminación de usuario con ID: {}&quot;, id);&#10;        if (id == null) throw new IllegalArgumentException(&quot;ID de usuario es requerido para eliminar&quot;);&#10;        if (!userRepository.existsById(id)) {&#10;            log.warn(&quot;Intento de eliminar usuario inexistente con ID: {}&quot;, id);&#10;            throw new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;        }&#10;        log.debug(&quot;Usuario encontrado para eliminación ID: {}&quot;, id);&#10;        try{&#10;            userRepository.deleteById(id);&#10;            log.info(&quot;Usuario eliminado exitosamente con ID: {}&quot;, id);&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al eliminar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Error interno al eliminar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtener un usuario por ID&#10;     * @param id ID del usuario a buscar&#10;     * @return DTO de respuesta con los datos del usuario&#10;     */&#10;    public UserResponse getUserById(Long id) {&#10;        log.info(&quot;Iniciando obtención de usuario con ID: {}&quot;, id);&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de obtener usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;&#10;    /**&#10;     * Obtener todos los usuarios con paginación básica&#10;     * @param page número de página (inicia en 0)&#10;     * @param size cantidad de usuarios por página&#10;     * @return página de usuarios&#10;     */&#10;    public Page&lt;UserResponse&gt; getAllUsers(int page, int size) {&#10;        log.info(&quot;Obteniendo usuarios - Página: {}, Tamaño: {}&quot;, page, size);&#10;        if (page &lt;= 0 || size &lt;= 0)  {&#10;            log.warn(&quot;Parámetros de paginación inválidos - Página: {}, Tamaño: {}&quot;, page, size);&#10;            throw new BusinessException(&quot;Parámetros de paginación inválidos&quot;);&#10;        }&#10;        try {&#10;            // Crear paginación ordenada por ID&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;id&quot;));&#10;&#10;            // Obtener página de usuarios de la BD&#10;            Page&lt;User&gt; userPage = userRepository.findAll(pageable);&#10;&#10;            log.info(&quot;Se encontraron {} usuarios en página {} de {}&quot;,&#10;                    userPage.getContent().size(), page, userPage.getTotalPages());&#10;&#10;            // Convertir a DTOs y retornar&#10;            return userPage.map(userMapper::toResponse);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al obtener usuarios: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al obtener usuarios&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Buscar usuarios por nombre con paginación&#10;     * @param firstName nombre a buscar&#10;     * @param page número de página&#10;     * @param size tamaño de página&#10;     * @return página de usuarios que coincidan&#10;     */&#10;    public Page&lt;UserResponse&gt; searchUsersByName(String firstName, int page, int size) {&#10;        log.info(&quot;Buscando usuarios por nombre: '{}' - Página: {}, Tamaño: {}&quot;, firstName, page, size);&#10;&#10;        try {&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;firstName&quot;));&#10;            Page&lt;User&gt; userPage = userRepository.findByFirstNameContainingIgnoreCase(firstName, pageable);&#10;&#10;            log.info(&quot;Se encontraron {} usuarios con nombre: '{}'&quot;, userPage.getContent().size(), firstName);&#10;            return userPage.map(userMapper::toResponse);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error en búsqueda por nombre: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno en búsqueda&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>