<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/reset-db.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/reset-db.bat" />
              <option name="updatedContent" value="@echo off&#10;REM ===================================================================&#10;REM Reset de Base de Datos - User Management API (Windows)&#10;REM ===================================================================&#10;&#10;echo ️  Reseteando base de datos...&#10;&#10;REM Confirmar la acción&#10;set /p confirm=&quot;⚠️  ¿Estás seguro de resetear la base de datos? (y/N): &quot;&#10;if /i not &quot;%confirm%&quot;==&quot;y&quot; (&#10;    echo ❌ Operación cancelada&#10;    exit /b 0&#10;)&#10;&#10;REM Parar la aplicación si está corriendo&#10;echo ⏹️  Deteniendo servicios...&#10;docker-compose down&#10;&#10;REM Eliminar volúmenes de datos&#10;echo  Eliminando datos persistentes...&#10;docker-compose down -v&#10;docker volume prune -f&#10;&#10;REM Levantar PostgreSQL limpio&#10;echo  Levantando PostgreSQL limpio...&#10;docker-compose up -d postgres&#10;&#10;REM Esperar a que esté listo&#10;echo ⏳ Esperando PostgreSQL...&#10;timeout /t 10 /nobreak &gt;nul&#10;&#10;echo.&#10;echo  Base de datos reseteada exitosamente!&#10;echo.&#10;echo  Próximos pasos:&#10;echo    1. Ejecutar: mvnw spring-boot:run&#10;echo    2. Flyway creará las tablas automáticamente&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.security.CustomUserDetailsService;&#10;import com.sordi.userManagement.security.JwtAuthenticationFilter;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;&#10;/**&#10; * Configuración de seguridad para la aplicación.&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    // Dependencias necesarias para la configuración de seguridad&#10;    private final CustomUserDetailsService customUserDetailsService;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    /**&#10;     * Bean para el codificador de contraseñas.&#10;     */&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    /**&#10;     * Bean para el AuthenticationManager.&#10;     */&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(&#10;            AuthenticationConfiguration authConfig) throws Exception {&#10;        return authConfig.getAuthenticationManager();&#10;    }&#10;&#10;    /**&#10;     * Bean de SecurityFilterChain - Define las reglas de seguridad de la aplicación.&#10;     */&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            // Deshabilitar Cross-Site Request Forgery (CSRF)&#10;            .csrf(AbstractHttpConfigurer::disable)&#10;&#10;            // Configurar sesiones como STATELESS (para JWT)&#10;            // No guardamos estado en el servidor&#10;            .sessionManagement(session -&gt;&#10;                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;&#10;            // Configurar qué endpoints requieren autenticación&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                // ENDPOINTS PÚBLICOS (sin autenticación)&#10;                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()        // Login, register&#10;                .requestMatchers(&quot;/h2-console/**&quot;).permitAll()         // Base de datos H2 - solo desarrollo&#10;&#10;                // ENDPOINTS OPCIONALES&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;).permitAll()         //  Documentación Swagger&#10;                .requestMatchers(&quot;/v3/api-docs/**&quot;).permitAll()        //  Datos para Swagger&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()           //  Monitoreo de aplicación&#10;&#10;                // ENDPOINTS PRIVADOS (requieren autenticación)&#10;                .anyRequest().authenticated()&#10;            )&#10;&#10;            // Configurar el filtro de autenticación JWT&#10;            // Este filtro intercepta las solicitudes y verifica el token JWT&#10;            // Si el token es válido, permite el acceso al recurso solicitado&#10;            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)&#10;&#10;            // Configurar headers para H2 console (solo desarrollo)&#10;            // H2 usa frames y Spring Security los bloquea por defecto&#10;            .headers(headers -&gt; headers&#10;                .frameOptions(HeadersConfigurer.FrameOptionsConfig::disable)&#10;            );&#10;&#10;        return http.build();&#10;    }&#10;    @Bean&#10;    public JwtAuthenticationFilter jwtAuthenticationFilter() {&#10;        return new JwtAuthenticationFilter(jwtTokenProvider,customUserDetailsService);}&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#13;&#10;&#13;&#10;import com.sordi.userManagement.security.CustomUserDetailsService;&#13;&#10;import com.sordi.userManagement.security.JwtAuthenticationFilter;&#13;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#13;&#10;import lombok.RequiredArgsConstructor;&#13;&#10;import org.springframework.context.annotation.Bean;&#13;&#10;import org.springframework.context.annotation.Configuration;&#13;&#10;import org.springframework.security.authentication.AuthenticationManager;&#13;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#13;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#13;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#13;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#13;&#10;import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;&#13;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#13;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#13;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#13;&#10;import org.springframework.security.web.SecurityFilterChain;&#13;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#13;&#10;&#13;&#10;/**&#13;&#10; * Configuración de seguridad para la aplicación.&#13;&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#13;&#10; */&#13;&#10;@Configuration&#13;&#10;@EnableWebSecurity&#13;&#10;@RequiredArgsConstructor&#13;&#10;public class SecurityConfig {&#13;&#10;&#13;&#10;    // Dependencias necesarias para la configuración de seguridad&#13;&#10;    private final CustomUserDetailsService customUserDetailsService;&#13;&#10;    private final JwtTokenProvider jwtTokenProvider;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Bean para el codificador de contraseñas.&#13;&#10;     */&#13;&#10;    @Bean&#13;&#10;    public PasswordEncoder passwordEncoder() {&#13;&#10;        return new BCryptPasswordEncoder();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Bean para el AuthenticationManager.&#13;&#10;     */&#13;&#10;    @Bean&#13;&#10;    public AuthenticationManager authenticationManager(&#13;&#10;            AuthenticationConfiguration authConfig) throws Exception {&#13;&#10;        return authConfig.getAuthenticationManager();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Bean de SecurityFilterChain - Define las reglas de seguridad de la aplicación.&#13;&#10;     */&#13;&#10;    @Bean&#13;&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#13;&#10;        http&#13;&#10;            // Deshabilitar Cross-Site Request Forgery (CSRF)&#13;&#10;            .csrf(AbstractHttpConfigurer::disable)&#13;&#10;&#13;&#10;            // Configurar sesiones como STATELESS (para JWT)&#13;&#10;            // No guardamos estado en el servidor&#13;&#10;            .sessionManagement(session -&gt;&#13;&#10;                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#13;&#10;&#13;&#10;            // Configurar qué endpoints requieren autenticación&#13;&#10;            .authorizeHttpRequests(auth -&gt; auth&#13;&#10;                // ENDPOINTS PÚBLICOS (sin autenticación)&#13;&#10;                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()        // Login, register&#13;&#10;                .requestMatchers(&quot;/h2-console/**&quot;).permitAll()         // Base de datos H2 - solo desarrollo&#13;&#10;&#13;&#10;                // ENDPOINTS OPCIONALES&#13;&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;).permitAll()         //  Documentación Swagger&#13;&#10;                .requestMatchers(&quot;/v3/api-docs/**&quot;).permitAll()        //  Datos para Swagger&#13;&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()           //  Monitoreo de aplicación&#13;&#10;&#13;&#10;                // ENDPOINTS PRIVADOS CON ROLES&#13;&#10;                .requestMatchers(&quot;/api/users/**&quot;).hasAnyRole(&quot;USER&quot;, &quot;ADMIN&quot;)  // Usuarios autenticados&#13;&#10;                .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)             // Solo administradores&#13;&#10;&#13;&#10;                // ENDPOINTS PRIVADOS (requieren autenticación)&#13;&#10;                .anyRequest().authenticated()&#13;&#10;            )&#13;&#10;&#13;&#10;            // Configurar el filtro de autenticación JWT&#13;&#10;            // Este filtro intercepta las solicitudes y verifica el token JWT&#13;&#10;            // Si el token es válido, permite el acceso al recurso solicitado&#13;&#10;            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)&#13;&#10;&#13;&#10;            // Configurar headers para H2 console (solo desarrollo)&#13;&#10;            // H2 usa frames y Spring Security los bloquea por defecto&#13;&#10;            .headers(headers -&gt; headers&#13;&#10;                .frameOptions(HeadersConfigurer.FrameOptionsConfig::disable)&#13;&#10;            );&#13;&#10;&#13;&#10;        return http.build();&#13;&#10;    }&#13;&#10;    @Bean&#13;&#10;    public JwtAuthenticationFilter jwtAuthenticationFilter() {&#13;&#10;        return new JwtAuthenticationFilter(jwtTokenProvider,customUserDetailsService);}&#13;&#10;&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.interceptor.TokenRefreshInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Configuración de interceptores HTTP&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final TokenRefreshInterceptor tokenRefreshInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(tokenRefreshInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Aplicar a todas las rutas de la API&#10;                .excludePathPatterns(&#10;                    &quot;/api/auth/login&quot;,&#10;                    &quot;/api/auth/register&quot;, &#10;                    &quot;/api/auth/refresh&quot;&#10;                ); // Excluir endpoints públicos&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.interceptor;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.sordi.userManagement.model.dto.response.TokenExpiredResponse;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import io.jsonwebtoken.ExpiredJwtException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.servlet.HandlerInterceptor;&#10;&#10;/**&#10; * Interceptor para manejar automáticamente la renovación de tokens&#10; * Se ejecuta ANTES de que llegue al controlador&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class TokenRefreshInterceptor implements HandlerInterceptor {&#10;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;&#10;    @Override&#10;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {&#10;        &#10;        // Solo procesar rutas que requieren autenticación (excluir /auth/login, /auth/register, etc.)&#10;        String requestURI = request.getRequestURI();&#10;        if (isPublicEndpoint(requestURI)) {&#10;            return true; // Continuar sin validar token&#10;        }&#10;&#10;        String jwt = extractTokenFromRequest(request);&#10;        &#10;        if (jwt != null) {&#10;            try {&#10;                // Si el token es válido, continuar normalmente&#10;                if (jwtTokenProvider.validateToken(jwt)) {&#10;                    return true;&#10;                }&#10;            } catch (ExpiredJwtException ex) {&#10;                // Token expirado - enviar respuesta específica&#10;                log.info(&quot;Token expirado detectado en interceptor para usuario: {}&quot;, ex.getClaims().getSubject());&#10;                sendTokenExpiredResponse(response);&#10;                return false; // Detener procesamiento&#10;            }&#10;        }&#10;        &#10;        return true; // Continuar si no hay token o token inválido (lo manejará el filtro de seguridad)&#10;    }&#10;&#10;    /**&#10;     * Verifica si el endpoint es público (no requiere autenticación)&#10;     */&#10;    private boolean isPublicEndpoint(String requestURI) {&#10;        return requestURI.startsWith(&quot;/api/auth/login&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/register&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/refresh&quot;) ||&#10;               requestURI.startsWith(&quot;/actuator&quot;) ||&#10;               requestURI.startsWith(&quot;/swagger&quot;) ||&#10;               requestURI.startsWith(&quot;/v3/api-docs&quot;);&#10;    }&#10;&#10;    /**&#10;     * Extrae el token del header Authorization&#10;     */&#10;    private String extractTokenFromRequest(HttpServletRequest request) {&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            return bearerToken.substring(7);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Envía respuesta JSON indicando que el token expiró&#10;     */&#10;    private void sendTokenExpiredResponse(HttpServletResponse response) throws Exception {&#10;        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);&#10;        response.setContentType(&quot;application/json&quot;);&#10;        response.setCharacterEncoding(&quot;UTF-8&quot;);&#10;&#10;        TokenExpiredResponse expiredResponse = TokenExpiredResponse.createRefreshRequired();&#10;        String jsonResponse = objectMapper.writeValueAsString(expiredResponse);&#10;        &#10;        response.getWriter().write(jsonResponse);&#10;        response.getWriter().flush();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/Role.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/Role.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model;&#10;&#10;/**&#10; * Enum para los roles de usuario en el sistema&#10; */&#10;public enum Role {&#10;    USER,&#10;    ADMIN&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/User.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class User {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(name = &quot;first_name&quot;, nullable = false, length = 50)&#10;    private String firstName;&#10;&#10;    @Column(name = &quot;last_name&quot;, nullable = false, length = 50)&#10;    private String lastName;&#10;&#10;    @Column(name = &quot;date_of_birth&quot;, nullable = false)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @Column(name = &quot;dni&quot;, nullable = false, unique = true, length = 10)&#10;    private String dni;&#10;&#10;    @Column(name = &quot;email&quot;, nullable = true, unique = true, length = 100)&#10;    private String email;&#10;&#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true, length = 50)&#10;    private String username;&#10;&#10;    @Column(name = &quot;password&quot;, nullable = false, length = 100)&#10;    private String password;&#10;&#10;    @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)&#10;    private LocalDateTime createdAt;&#10;&#10;    @Column(name = &quot;updated_at&quot;, nullable = false)&#10;    private LocalDateTime updatedAt;&#10;&#10;    @PrePersist&#10;    protected void onCreate() {&#10;        this.createdAt = LocalDateTime.now();&#10;        this.updatedAt = LocalDateTime.now();&#10;    }&#10;&#10;    @PreUpdate&#10;    protected void onUpdate() {&#10;        this.updatedAt = LocalDateTime.now();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model;&#13;&#10;&#13;&#10;import jakarta.persistence.*;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;&#13;&#10;@Entity&#13;&#10;@Table(name = &quot;users&quot;)&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class User {&#13;&#10;&#13;&#10;    @Id&#13;&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#13;&#10;    private Long id;&#13;&#10;&#13;&#10;    @Column(name = &quot;first_name&quot;, nullable = false, length = 50)&#13;&#10;    private String firstName;&#13;&#10;&#13;&#10;    @Column(name = &quot;last_name&quot;, nullable = false, length = 50)&#13;&#10;    private String lastName;&#13;&#10;&#13;&#10;    @Column(name = &quot;date_of_birth&quot;, nullable = false)&#13;&#10;    private LocalDate dateOfBirth;&#13;&#10;&#13;&#10;    @Column(name = &quot;dni&quot;, nullable = false, unique = true, length = 10)&#13;&#10;    private String dni;&#13;&#10;&#13;&#10;    @Column(name = &quot;email&quot;, nullable = true, unique = true, length = 100)&#13;&#10;    private String email;&#13;&#10;&#13;&#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true, length = 50)&#13;&#10;    private String username;&#13;&#10;&#13;&#10;    @Column(name = &quot;password&quot;, nullable = false, length = 100)&#13;&#10;    private String password;&#13;&#10;&#13;&#10;    @Enumerated(EnumType.STRING)&#13;&#10;    @Column(name = &quot;role&quot;, nullable = false, length = 20)&#13;&#10;    private Role role = Role.USER;&#13;&#10;&#13;&#10;    @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    @Column(name = &quot;updated_at&quot;, nullable = false)&#13;&#10;    private LocalDateTime updatedAt;&#13;&#10;&#13;&#10;    @PrePersist&#13;&#10;    protected void onCreate() {&#13;&#10;        this.createdAt = LocalDateTime.now();&#13;&#10;        this.updatedAt = LocalDateTime.now();&#13;&#10;    }&#13;&#10;&#13;&#10;    @PreUpdate&#13;&#10;    protected void onUpdate() {&#13;&#10;        this.updatedAt = LocalDateTime.now();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/mapper/UserMapper.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.Role;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.*;&#10;&#10;import java.util.List;&#10;&#10;@Mapper(&#10;        componentModel = &quot;spring&quot;,&#10;        injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;        unmappedSourcePolicy = ReportingPolicy.IGNORE&#10;)&#10;public interface UserMapper {&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;fullName&quot;, expression =&quot;java(buildFullName(user.getFirstName(), user.getLastName()))&quot;),&#10;    })&#10;    UserResponse toResponse(User user);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true), // Este campo se maneja automáticamente&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true)&#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;dni&quot;, ignore = true), // DNI no se puede actualizar&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;username&quot;, ignore = true),&#10;            @Mapping(target = &quot;password&quot;, ignore = true)&#10;    })&#10;    void updateEntity(@MappingTarget User user , UpdateUserRequest request);&#10;&#10;    List&lt;UserResponse&gt; toResponseList(List&lt;User&gt;users) ;&#10;&#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.mapper;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.Role;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import org.mapstruct.*;&#10;&#10;import java.util.List;&#10;&#10;@Mapper(&#10;        componentModel = &quot;spring&quot;,&#10;        injectionStrategy = InjectionStrategy.CONSTRUCTOR,&#10;        unmappedSourcePolicy = ReportingPolicy.IGNORE&#10;)&#10;public interface UserMapper {&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;fullName&quot;, expression =&quot;java(buildFullName(user.getFirstName(), user.getLastName()))&quot;),&#10;    })&#10;    UserResponse toResponse(User user);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true), // Este campo se maneja automáticamente&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;role&quot;, expression = &quot;java(mapStringToRole(request.getRole()))&quot;)&#10;    })&#10;    User toEntity(CreateUserRequest request);&#10;&#10;    @Mappings({&#10;            @Mapping(target = &quot;id&quot;, ignore = true), // Este campo no debe mappearse&#10;            @Mapping(target = &quot;dni&quot;, ignore = true), // DNI no se puede actualizar&#10;            @Mapping(target = &quot;createdAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;updatedAt&quot;, ignore = true),&#10;            @Mapping(target = &quot;username&quot;, ignore = true),&#10;            @Mapping(target = &quot;password&quot;, ignore = true)&#10;    })&#10;    void updateEntity(@MappingTarget User user , UpdateUserRequest request);&#10;&#10;    List&lt;UserResponse&gt; toResponseList(List&lt;User&gt;users) ;&#10;&#10;    default String buildFullName(String firstName, String lastName){&#10;        if(firstName == null &amp;&amp; lastName == null) return &quot;&quot;;&#10;        if(firstName == null) return lastName;&#10;        if(lastName == null) return firstName;&#10;        return firstName + &quot; &quot; + lastName;&#10;    }&#10;&#10;    default Role mapStringToRole(String role) {&#10;        if (role == null) {&#10;            return null;&#10;        }&#10;        return Role.valueOf(role.toUpperCase());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10; * DTO para actualización de usuario por parte del administrador.&#10; * Incluye campos que solo admin puede modificar como isActive.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Schema(description = &quot;Request para actualización de usuario por administrador&quot;)&#10;public class AdminUpdateUserRequest {&#10;&#10;    @Schema(description = &quot;Nombre del usuario&quot;, example = &quot;Juan&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El nombre debe tener entre 2 y 50 caracteres&quot;)&#10;    private String firstName;&#10;&#10;    @Schema(description = &quot;Apellido del usuario&quot;, example = &quot;Pérez&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El apellido debe tener entre 2 y 50 caracteres&quot;)&#10;    private String lastName;&#10;&#10;    @Schema(description = &quot;Email del usuario&quot;, example = &quot;juan.perez@email.com&quot;)&#10;    @Email(message = &quot;Formato de email inválido&quot;)&#10;    private String email;&#10;&#10;    @Schema(description = &quot;Estado activo del usuario&quot;, example = &quot;true&quot;)&#10;    private Boolean isActive; // ✅ Solo admin puede cambiar esto&#10;&#10;    @Schema(description = &quot;Rol del usuario&quot;, example = &quot;USER&quot;)&#10;    private String role; // ✅ Solo admin puede cambiar roles&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUserRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; *&#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]{8,}$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; *&#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]{8,}$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;&#10;    // Campo role opcional - por defecto será USER&#10;    private String role = &quot;USER&quot;; // Puede ser &quot;USER&quot; o &quot;ADMIN&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>