<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;&#10;/**&#10; * Configuración de seguridad para la aplicación.&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final UserRepository userRepository;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    &#10;    &#10;    &#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;/**&#10; * Configuración de seguridad para la aplicación.&#10; * Define beans de seguridad, reglas de autenticación y autorización.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    // Dependencias necesarias para la configuración de seguridad&#10;    private final UserRepository userRepository;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;&#10;    /**&#10;     * Bean de PasswordEncoder usando BCrypt.&#10;     * BCrypt es el algoritmo más seguro y recomendado para encriptar contraseñas.&#10;     * &#10;     * ¿Qué hace BCrypt?&#10;     * - Genera un &quot;salt&quot; aleatorio para cada contraseña&#10;     * - Aplica múltiples rondas de encriptación (por defecto 10)&#10;     * - Es resistente a ataques de fuerza bruta&#10;     * - Es irreversible (no se puede desencriptar)&#10;     * &#10;     * ¿Cuándo se usa?&#10;     * - UserService.createUser() → encriptar contraseña nueva&#10;     * - UserService.updateUser() → encriptar contraseña actualizada  &#10;     * - AuthService.verifyCredentials() → verificar contraseña en login&#10;     */&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10; * DTO para actualización de usuario por parte del administrador.&#10; * Incluye campos que solo admin puede modificar como isActive.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Schema(description = &quot;Request para actualización de usuario por administrador&quot;)&#10;public class AdminUpdateUserRequest {&#10;&#10;    @Schema(description = &quot;Nombre del usuario&quot;, example = &quot;Juan&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El nombre debe tener entre 2 y 50 caracteres&quot;)&#10;    private String firstName;&#10;&#10;    @Schema(description = &quot;Apellido del usuario&quot;, example = &quot;Pérez&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El apellido debe tener entre 2 y 50 caracteres&quot;)&#10;    private String lastName;&#10;&#10;    @Schema(description = &quot;Email del usuario&quot;, example = &quot;juan.perez@email.com&quot;)&#10;    @Email(message = &quot;Formato de email inválido&quot;)&#10;    private String email;&#10;&#10;    @Schema(description = &quot;Estado activo del usuario&quot;, example = &quot;true&quot;)&#10;    private Boolean isActive; // ✅ Solo admin puede cambiar esto&#10;&#10;    @Schema(description = &quot;Rol del usuario&quot;, example = &quot;USER&quot;)&#10;    private String role; // ✅ Solo admin puede cambiar roles&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/JwtResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/response/JwtResponse.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonProperty;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * JWT authentication response following OAuth2 and industry standards.&#10; * Used after successful login or token refresh operations.&#10;&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class JwtResponse {&#10;&#10;    /**&#10;     * The JWT access token&#10;     */&#10;    @JsonProperty(&quot;access_token&quot;)&#10;    private String accessToken;&#10;&#10;    /**&#10;     * Token type (always &quot;Bearer&quot; for JWT)&#10;     */&#10;    @JsonProperty(&quot;token_type&quot;)&#10;    private String tokenType = &quot;Bearer&quot;;&#10;&#10;    /**&#10;     * Token expiration time in seconds&#10;     */&#10;    @JsonProperty(&quot;expires_in&quot;)&#10;    private long expiresIn;&#10;&#10;    /**&#10;     * Refresh token for obtaining new access tokens&#10;     */&#10;    @JsonProperty(&quot;refresh_token&quot;)&#10;    private String refreshToken;&#10;&#10;    /**&#10;     * Token scope/permissions (optional)&#10;     */&#10;    private String scope;&#10;&#10;    /**&#10;     * When the token was issued&#10;     */&#10;    @JsonProperty(&quot;issued_at&quot;)&#10;    private LocalDateTime issuedAt;&#10;&#10;    /**&#10;     * Constructor for basic JWT response&#10;     */&#10;    public JwtResponse(String accessToken, long expiresIn) {&#10;        this.accessToken = accessToken;&#10;        this.tokenType = &quot;Bearer&quot;;&#10;        this.expiresIn = expiresIn;&#10;        this.issuedAt = LocalDateTime.now();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonProperty;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Respuesta de autenticación JWT siguiendo estándares OAuth2 e industriales.&#10; * Se usa después de operaciones exitosas de login o renovación de token.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class JwtResponse {&#10;&#10;    /**&#10;     * El token de acceso JWT&#10;     */&#10;    @JsonProperty(&quot;access_token&quot;)&#10;    private String accessToken;&#10;&#10;    /**&#10;     * Tipo de token (siempre &quot;Bearer&quot; para JWT)&#10;     */&#10;    @JsonProperty(&quot;token_type&quot;)&#10;    private String tokenType = &quot;Bearer&quot;;&#10;&#10;    /**&#10;     * Tiempo de expiración del token en segundos&#10;     */&#10;    @JsonProperty(&quot;expires_in&quot;)&#10;    private long expiresIn;&#10;&#10;    /**&#10;     * Token de renovación para obtener nuevos tokens de acceso&#10;     */&#10;    @JsonProperty(&quot;refresh_token&quot;)&#10;    private String refreshToken;&#10;&#10;    /**&#10;     * Alcance/permisos del token (opcional)&#10;     */&#10;    private String scope;&#10;&#10;    /**&#10;     * Cuándo se emitió el token&#10;     */&#10;    @JsonProperty(&quot;issued_at&quot;)&#10;    private LocalDateTime issuedAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/repository/UserRepository.java" />
              <option name="originalContent" value="package com.sordi.userManagement.repository;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Repository interface for User entity.&#10; *&#10; * Provides CRUD operations and custom queries for User management.&#10; * Extends JpaRepository which provides basic CRUD operations.&#10;&#10; */&#10;@Repository&#10;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    &#10;    /**&#10;     * Find a user by their email address.&#10;     *&#10;     * @param email the email to search for&#10;     * @return Optional containing the user if found, empty otherwise&#10;     */&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;&#10;    /**&#10;     * Find a user by their username.&#10;     *&#10;     * @param username the username to search for&#10;     * @return Optional containing the user if found, empty otherwise&#10;     */&#10;    Optional&lt;User&gt; findByUsername(String username);&#10;&#10;    /**&#10;     * Check if a user exists with the given email.&#10;     *&#10;     * @param email the email to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByEmail(String email);&#10;&#10;    /**&#10;     * Check if a user exists with the given DNI.&#10;     *&#10;     * @param dni the DNI to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByDni(String dni);&#10;&#10;    /**&#10;     * Check if a user exists with the given username.&#10;     *&#10;     * @param username the username to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByUsername(String username);&#10;    &#10;    O&#10;    &#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.repository;&#10;&#10;import com.sordi.userManagement.model.User;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Repository interface for User entity.&#10; * Provides CRUD operations and custom queries for User management.&#10; */&#10;@Repository&#10;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;&#10;    /**&#10;     * Find a user by their email address.&#10;     *&#10;     * @param email the email to search for&#10;     * @return Optional containing the user if found, empty otherwise&#10;     */&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;&#10;    /**&#10;     * Find a user by their username.&#10;     *&#10;     * @param username the username to search for&#10;     * @return Optional containing the user if found, empty otherwise&#10;     */&#10;    Optional&lt;User&gt; findByUsername(String username);&#10;&#10;    /**&#10;     * Check if a user exists with the given email.&#10;     *&#10;     * @param email the email to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByEmail(String email);&#10;&#10;    /**&#10;     * Check if a user exists with the given DNI.&#10;     *&#10;     * @param dni the DNI to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByDni(String dni);&#10;&#10;    /**&#10;     * Check if a user exists with the given username.&#10;     *&#10;     * @param username the username to check&#10;     * @return true if user exists, false otherwise&#10;     */&#10;    boolean existsByUsername(String username);&#10;&#10;    /**&#10;     * Find a user by email or username (useful for login).&#10;     *&#10;     * @param email the email to search for&#10;     * @param username the username to search for&#10;     * @return Optional containing the user if found, empty otherwise&#10;     */&#10;    @Query(&quot;SELECT u FROM User u WHERE u.email = :email OR u.username = :username&quot;)&#10;    Optional&lt;User&gt; findByEmailOrUsername(@Param(&quot;email&quot;) String email, @Param(&quot;username&quot;) String username);&#10;&#10;    // ✅ PAGINACIÓN SIMPLE&#10;    /**&#10;     * Obtener todos los usuarios con paginación&#10;     * Hereda de JpaRepository automáticamente: Page&lt;User&gt; findAll(Pageable pageable)&#10;     */&#10;&#10;    /**&#10;     * Buscar usuarios por nombre con paginación&#10;     * @param firstName nombre a buscar&#10;     * @param pageable configuración de paginación&#10;     * @return página de usuarios&#10;     */&#10;    Page&lt;User&gt; findByFirstNameContainingIgnoreCase(String firstName, Pageable pageable);&#10;&#10;    /**&#10;     * Buscar usuarios por email con paginación&#10;     * @param email email a buscar&#10;     * @param pageable configuración de paginación&#10;     * @return página de usuarios&#10;     */&#10;    Page&lt;User&gt; findByEmailContainingIgnoreCase(String email, Pageable pageable);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/AuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/AuthService.java" />
              <option name="originalContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.core.AuthenticationException;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Servicio de autenticación - Maneja login y JWT tokens&#10; * Solo se encarga de autenticar usuarios existentes&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class AuthService {&#10;    &#10;    private final UserRepository userRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final AuthenticationManager authenticationManager;&#10;    &#10;    /**&#10;     * Método principal de login&#10;     * @param loginRequest credenciales del usuario&#10;     * @return JwtResponse con el token generado&#10;     */&#10;    public JwtResponse login(LoginRequest loginRequest) {&#10;        log.info(&quot;Intento de login para usuario: {}&quot;, loginRequest.getUsername());&#10;        &#10;        try {&#10;            Authentication authentication = authenticationManager.authenticate(&#10;                new UsernamePasswordAuthenticationToken(&#10;                    loginRequest.getUsername(),&#10;                    loginRequest.getPassword()&#10;                )&#10;            );&#10;            &#10;            // Buscar el usuario en la BD para obtener sus datos&#10;            User user = userRepository.findByUsername(loginRequest.getUsername())&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Usuario autenticado pero no encontrado en BD: {}&quot;, loginRequest.getUsername());&#10;                    return new BusinessException(&quot;Error interno de autenticación&quot;);&#10;                });&#10;            &#10;            //  Generar JWT token&#10;            String token = jwtTokenProvider.generateToken(user.getUsername());&#10;            &#10;            log.info(&quot;Login exitoso para usuario: {}&quot;, user.getUsername());&#10;            &#10;            // Crear y retornar respuesta&#10;            return JwtResponse.builder()&#10;                .accessToken(token)              // ✅ Campo correcto (no 'token')&#10;                .tokenType(&quot;Bearer&quot;)             // ✅ Campo correcto (no 'type')&#10;                .expiresIn(3600)                 // ✅ Tiempo de expiración en segundos&#10;                .issuedAt(LocalDateTime.now())   // ✅ Cuándo se emitió&#10;                // refreshToken se puede agregar después si es necesario&#10;                .build();&#10;                &#10;        } catch (AuthenticationException e) {&#10;            log.warn(&quot;Credenciales inválidas para usuario: {}&quot;, loginRequest.getUsername());&#10;            throw new BusinessException(&quot;Credenciales inválidas&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado durante login: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno del servidor&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Validar si un token JWT es válido&#10;     * @param token JWT token a validar&#10;     * @return true si es válido, false si no&#10;     */&#10;    public boolean validateToken(String token) {&#10;        try {&#10;            boolean isValid = jwtTokenProvider.validateToken(token);&#10;            log.debug(&quot;Validación de token: {}&quot;, isValid ? &quot;VÁLIDO&quot; : &quot;INVÁLIDO&quot;);&#10;            return isValid;&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Error al validar token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Extraer username de un JWT token&#10;     * @param token JWT token&#10;     * @return username contenido en el token&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        try {&#10;            String username = jwtTokenProvider.getUsernameFromToken(token);&#10;            log.debug(&quot;Username extraído del token: {}&quot;, username);&#10;            return username;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al extraer username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Token inválido&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verificar si las credenciales son correctas sin generar token&#10;     * Útil para operaciones que requieren confirmación de contraseña&#10;     * @param username nombre de usuario&#10;     * @param password contraseña en texto plano&#10;     * @return true si las credenciales son válidas&#10;     */&#10;    public boolean verifyCredentials(String username, String password) {&#10;        log.debug(&quot;Verificando credenciales para usuario: {}&quot;, username);&#10;        &#10;        try {&#10;            User user = userRepository.findByUsername(username).orElse(null);&#10;            &#10;            if (user == null) {&#10;                log.debug(&quot;Usuario no encontrado: {}&quot;, username);&#10;                return false;&#10;            }&#10;            &#10;            boolean isValid = passwordEncoder.matches(password, user.getPassword());&#10;            log.debug(&quot;Verificación de credenciales para {}: {}&quot;, &#10;                     username, isValid ? &quot;VÁLIDA&quot; : &quot;INVÁLIDA&quot;);&#10;            &#10;            return isValid;&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al verificar credenciales: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Logout - En JWT stateless típicamente no hay acción específica&#10;     * El cliente simplemente descarta el token&#10;     * @param token token a &quot;invalidar&quot;&#10;     */&#10;    public void logout(String token) {&#10;        // En JWT stateless no hay estado en servidor que limpiar&#10;        // El cliente simplemente borra el token&#10;        log.info(&quot;Logout ejecutado - Cliente debe descartar el token&quot;);&#10;        &#10;        // TODO: Si en el futuro implementamos blacklist de tokens,&#10;        // aquí agregaríamos el token a la lista negra&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.core.AuthenticationException;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Servicio de autenticación - Maneja login y JWT tokens&#10; * Solo se encarga de autenticar usuarios existentes&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class AuthService {&#10;    &#10;    private final UserRepository userRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final AuthenticationManager authenticationManager;&#10;    &#10;    /**&#10;     * Método principal de login&#10;     * @param loginRequest credenciales del usuario&#10;     * @return JwtResponse con el token generado&#10;     */&#10;    public JwtResponse login(LoginRequest loginRequest) {&#10;        log.info(&quot;Intento de login para usuario: {}&quot;, loginRequest.getUsername());&#10;        &#10;        try {&#10;            Authentication authentication = authenticationManager.authenticate(&#10;                new UsernamePasswordAuthenticationToken(&#10;                    loginRequest.getUsername(),&#10;                    loginRequest.getPassword()&#10;                )&#10;            );&#10;            &#10;            // Buscar el usuario en la BD para obtener sus datos&#10;            User user = userRepository.findByUsername(loginRequest.getUsername())&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Usuario autenticado pero no encontrado en BD: {}&quot;, loginRequest.getUsername());&#10;                    return new BusinessException(&quot;Error interno de autenticación&quot;);&#10;                });&#10;            &#10;            //  Generar JWT token&#10;            String token = jwtTokenProvider.generateToken(user.getUsername());&#10;            &#10;            log.info(&quot;Login exitoso para usuario: {}&quot;, user.getUsername());&#10;            &#10;            // Crear y retornar respuesta&#10;            return JwtResponse.builder()&#10;                .accessToken(token)              // ✅ Campo correcto (no 'token')&#10;                .tokenType(&quot;Bearer&quot;)             // ✅ Campo correcto (no 'type')&#10;                .expiresIn(3600)                 // ✅ Tiempo de expiración en segundos&#10;                .issuedAt(LocalDateTime.now())   // ✅ Cuándo se emitió&#10;                // refreshToken se puede agregar después si es necesario&#10;                .build();&#10;                &#10;        } catch (AuthenticationException e) {&#10;            log.warn(&quot;Credenciales inválidas para usuario: {}&quot;, loginRequest.getUsername());&#10;            throw new BusinessException(&quot;Credenciales inválidas&quot;);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado durante login: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno del servidor&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Validar si un token JWT es válido&#10;     * @param token JWT token a validar&#10;     * @return true si es válido, false si no&#10;     */&#10;    public boolean validateToken(String token) {&#10;        try {&#10;            boolean isValid = jwtTokenProvider.validateToken(token);&#10;            log.debug(&quot;Validación de token: {}&quot;, isValid ? &quot;VÁLIDO&quot; : &quot;INVÁLIDO&quot;);&#10;            return isValid;&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Error al validar token: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Extraer username de un JWT token&#10;     * @param token JWT token&#10;     * @return username contenido en el token&#10;     */&#10;    public String getUsernameFromToken(String token) {&#10;        try {&#10;            String username = jwtTokenProvider.getUsernameFromToken(token);&#10;            log.debug(&quot;Username extraído del token: {}&quot;, username);&#10;            return username;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al extraer username del token: {}&quot;, e.getMessage());&#10;            throw new BusinessException(&quot;Token inválido&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verificar si las credenciales son correctas sin generar token&#10;     * Útil para operaciones que requieren confirmación de contraseña&#10;     * @param username nombre de usuario&#10;     * @param password contraseña en texto plano&#10;     * @return true si las credenciales son válidas&#10;     */&#10;    public boolean verifyCredentials(String username, String password) {&#10;        log.debug(&quot;Verificando credenciales para usuario: {}&quot;, username);&#10;        &#10;        try {&#10;            User user = userRepository.findByUsername(username).orElse(null);&#10;            &#10;            if (user == null) {&#10;                log.debug(&quot;Usuario no encontrado: {}&quot;, username);&#10;                return false;&#10;            }&#10;            &#10;            boolean isValid = passwordEncoder.matches(password, user.getPassword());&#10;            log.debug(&quot;Verificación de credenciales para {}: {}&quot;, &#10;                     username, isValid ? &quot;VÁLIDA&quot; : &quot;INVÁLIDA&quot;);&#10;            &#10;            return isValid;&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al verificar credenciales: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Logout - En JWT stateless típicamente no hay acción específica&#10;     * El cliente simplemente descarta el token&#10;     * @param token token a &quot;invalidar&quot;&#10;     */&#10;    public void logout(String token) {&#10;        // En JWT stateless no hay estado en servidor que limpiar&#10;        // El cliente simplemente borra el token&#10;        log.info(&quot;Logout ejecutado - Cliente debe descartar el token&quot;);&#10;        &#10;        // TODO: Si en el futuro implementamos blacklist de tokens,&#10;        // aquí agregaríamos el token a la lista negra&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/service/UserService.java" />
              <option name="originalContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;&#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;&#10;            User savedUser = userRepository.save(user);&#10;&#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;,&#10;                    savedUser.getId(), savedUser.getUsername());&#10;&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;,&#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;&#10;    @Transactional&#10;    public UserResponse updateUser(Long id, UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;&#10;        if (id == null || request == null) {&#10;            throw new BusinessException(&quot;ID de usuario y datos de actualización son requeridos&quot;);&#10;        }&#10;&#10;        // Buscar usuario y lanzar excepción si no existe&#10;        User userExisting = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de actualizar usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        log.debug(&quot;Usuario encontrado para actualización: {}&quot;, userExisting.getUsername());&#10;&#10;        // Validar email único si se está cambiando&#10;        if (request.getEmail() != null &amp;&amp; !request.getEmail().equals(userExisting.getEmail())) {&#10;            if (userRepository.existsByEmail(request.getEmail())) {&#10;                log.warn(&quot;Intento de actualizar con email duplicado: {}&quot;, request.getEmail());&#10;                throw new BusinessException(&quot;El email ya está en uso por otro usuario&quot;);&#10;            }&#10;        }&#10;        try {&#10;            // Actualizar usando mapper&#10;            userMapper.updateEntity(userExisting, request);&#10;&#10;            // Guardar cambios&#10;            User savedUser = userRepository.save(userExisting);&#10;            log.info(&quot;Usuario actualizado exitosamente con ID: {}&quot;, savedUser.getId());&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al actualizar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw  new BusinessException(&quot;Error interno al actualizar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        log.info(&quot;Iniciando eliminación de usuario con ID: {}&quot;, id);&#10;        if (id == null) throw new BusinessException(&quot;ID de usuario es requerido para eliminar&quot;);&#10;        if (!userRepository.existsById(id)) {&#10;            log.warn(&quot;Intento de eliminar usuario inexistente con ID: {}&quot;, id);&#10;            throw new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;        }&#10;        log.debug(&quot;Usuario encontrado para eliminación ID: {}&quot;, id);&#10;        try{&#10;            userRepository.deleteById(id);&#10;            log.info(&quot;Usuario eliminado exitosamente con ID: {}&quot;, id);&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al eliminar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al eliminar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    public UserResponse getUserById(Long id) {&#10;        log.info(&quot;Iniciando obtención de usuario con ID: {}&quot;, id);&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de obtener usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;&#10;    /**&#10;     * Obtener todos los usuarios con paginación básica&#10;     * @param page número de página (inicia en 0)&#10;     * @param size cantidad de usuarios por página&#10;     * @return página de usuarios&#10;     */&#10;    public Page&lt;UserResponse&gt; getAllUsers(int page, int size) {&#10;        log.info(&quot;Obteniendo usuarios - Página: {}, Tamaño: {}&quot;, page, size);&#10;        &#10;        try {&#10;            // Crear paginación ordenada por ID&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;id&quot;));&#10;            &#10;            // Obtener página de usuarios de la BD&#10;            Page&lt;User&gt; userPage = userRepository.findAll(pageable);&#10;            &#10;            log.info(&quot;Se encontraron {} usuarios en página {} de {}&quot;, &#10;                    userPage.getContent().size(), page, userPage.getTotalPages());&#10;            &#10;            // Convertir a DTOs y retornar&#10;            return userPage.map(userMapper::toResponse);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al obtener usuarios: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al obtener usuarios&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Buscar usuarios por nombre con paginación&#10;     * @param firstName nombre a buscar&#10;     * @param page número de página&#10;     * @param size tamaño de página&#10;     * @return página de usuarios que coincidan&#10;     */&#10;    public Page&lt;UserResponse&gt; searchUsersByName(String firstName, int page, int size) {&#10;        log.info(&quot;Buscando usuarios por nombre: '{}' - Página: {}, Tamaño: {}&quot;, firstName, page, size);&#10;        &#10;        try {&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;firstName&quot;));&#10;            Page&lt;User&gt; userPage = userRepository.findByFirstNameContainingIgnoreCase(firstName, pageable);&#10;            &#10;            log.info(&quot;Se encontraron {} usuarios con nombre: '{}'&quot;, userPage.getContent().size(), firstName);&#10;            return userPage.map(userMapper::toResponse);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error en búsqueda por nombre: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno en búsqueda&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.exception.ResourceNotFoundException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import jakarta.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Servicio para gestión de usuarios - Solo CRUD&#10; * NO maneja autenticación (esa responsabilidad es del AuthService)&#10; */&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final UserMapper userMapper;&#10;    private final PasswordEncoder passwordEncoder; // ✅ Solo para encriptar contraseñas&#10;    // ❌ REMOVIDO JwtTokenProvider - no es responsabilidad de este service&#10;&#10;    @Transactional&#10;    public UserResponse createUser(CreateUserRequest request) {&#10;        log.info(&quot;Iniciando creación de usuario con username: {}&quot;, request.getUsername());&#10;&#10;        // Validaciones con logging&#10;        if(userRepository.existsByUsername(request.getUsername())) {&#10;            log.warn(&quot;Intento de registro fallido: Username '{}' ya existe&quot;, request.getUsername());&#10;            throw new BusinessException(&quot;Nombre de usuario ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByEmail(request.getEmail())) {&#10;            log.warn(&quot;Intento de registro fallido: Email '{}' ya existe&quot;, request.getEmail());&#10;            throw new BusinessException(&quot;Email ya esta en uso&quot;);&#10;        }&#10;        if(userRepository.existsByDni(request.getDni())) {&#10;            log.warn(&quot;Intento de registro fallido: DNI '{}' ya existe&quot;, request.getDni());&#10;            throw new BusinessException(&quot;DNI existente&quot;);&#10;        }&#10;&#10;        try {&#10;            User user = userMapper.toEntity(request);&#10;            user.setPassword(passwordEncoder.encode(request.getPassword()));&#10;&#10;            User savedUser = userRepository.save(user);&#10;&#10;            log.info(&quot;Usuario creado exitosamente con ID: {} y username: {}&quot;,&#10;                    savedUser.getId(), savedUser.getUsername());&#10;&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error inesperado al crear usuario con username: {}. Error: {}&quot;,&#10;                     request.getUsername(), e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al crear usuario&quot;);&#10;        }&#10;    }&#10;&#10;    @Transactional&#10;    public UserResponse updateUser(Long id, UpdateUserRequest request) {&#10;        log.info(&quot;Iniciando actualización de usuario con ID: {}&quot;, id);&#10;&#10;        if (id == null || request == null) {&#10;            throw new BusinessException(&quot;ID de usuario y datos de actualización son requeridos&quot;);&#10;        }&#10;&#10;        // Buscar usuario y lanzar excepción si no existe&#10;        User userExisting = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de actualizar usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        log.debug(&quot;Usuario encontrado para actualización: {}&quot;, userExisting.getUsername());&#10;&#10;        // Validar email único si se está cambiando&#10;        if (request.getEmail() != null &amp;&amp; !request.getEmail().equals(userExisting.getEmail())) {&#10;            if (userRepository.existsByEmail(request.getEmail())) {&#10;                log.warn(&quot;Intento de actualizar con email duplicado: {}&quot;, request.getEmail());&#10;                throw new BusinessException(&quot;El email ya está en uso por otro usuario&quot;);&#10;            }&#10;        }&#10;        try {&#10;            // Actualizar usando mapper&#10;            userMapper.updateEntity(userExisting, request);&#10;&#10;            // Guardar cambios&#10;            User savedUser = userRepository.save(userExisting);&#10;            log.info(&quot;Usuario actualizado exitosamente con ID: {}&quot;, savedUser.getId());&#10;            return userMapper.toResponse(savedUser);&#10;&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al actualizar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw  new BusinessException(&quot;Error interno al actualizar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        log.info(&quot;Iniciando eliminación de usuario con ID: {}&quot;, id);&#10;        if (id == null) throw new BusinessException(&quot;ID de usuario es requerido para eliminar&quot;);&#10;        if (!userRepository.existsById(id)) {&#10;            log.warn(&quot;Intento de eliminar usuario inexistente con ID: {}&quot;, id);&#10;            throw new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;        }&#10;        log.debug(&quot;Usuario encontrado para eliminación ID: {}&quot;, id);&#10;        try{&#10;            userRepository.deleteById(id);&#10;            log.info(&quot;Usuario eliminado exitosamente con ID: {}&quot;, id);&#10;        }catch (Exception e) {&#10;            log.error(&quot;Error inesperado al eliminar usuario con ID: {}&quot;, id, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al eliminar usuario&quot;);&#10;        }&#10;    }&#10;&#10;    public UserResponse getUserById(Long id) {&#10;        log.info(&quot;Iniciando obtención de usuario con ID: {}&quot;, id);&#10;        User user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.warn(&quot;Intento de obtener usuario inexistente con ID: {}&quot;, id);&#10;                    return new ResourceNotFoundException(&quot;Usuario con ID &quot; + id + &quot; no encontrado&quot;);&#10;                });&#10;&#10;        return userMapper.toResponse(user);&#10;    }&#10;&#10;    /**&#10;     * Obtener todos los usuarios con paginación básica&#10;     * @param page número de página (inicia en 0)&#10;     * @param size cantidad de usuarios por página&#10;     * @return página de usuarios&#10;     */&#10;    public Page&lt;UserResponse&gt; getAllUsers(int page, int size) {&#10;        log.info(&quot;Obteniendo usuarios - Página: {}, Tamaño: {}&quot;, page, size);&#10;        &#10;        try {&#10;            // Crear paginación ordenada por ID&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;id&quot;));&#10;            &#10;            // Obtener página de usuarios de la BD&#10;            Page&lt;User&gt; userPage = userRepository.findAll(pageable);&#10;            &#10;            log.info(&quot;Se encontraron {} usuarios en página {} de {}&quot;, &#10;                    userPage.getContent().size(), page, userPage.getTotalPages());&#10;            &#10;            // Convertir a DTOs y retornar&#10;            return userPage.map(userMapper::toResponse);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error al obtener usuarios: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno al obtener usuarios&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Buscar usuarios por nombre con paginación&#10;     * @param firstName nombre a buscar&#10;     * @param page número de página&#10;     * @param size tamaño de página&#10;     * @return página de usuarios que coincidan&#10;     */&#10;    public Page&lt;UserResponse&gt; searchUsersByName(String firstName, int page, int size) {&#10;        log.info(&quot;Buscando usuarios por nombre: '{}' - Página: {}, Tamaño: {}&quot;, firstName, page, size);&#10;        &#10;        try {&#10;            Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;firstName&quot;));&#10;            Page&lt;User&gt; userPage = userRepository.findByFirstNameContainingIgnoreCase(firstName, pageable);&#10;            &#10;            log.info(&quot;Se encontraron {} usuarios con nombre: '{}'&quot;, userPage.getContent().size(), firstName);&#10;            return userPage.map(userMapper::toResponse);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Error en búsqueda por nombre: {}&quot;, e.getMessage(), e);&#10;            throw new BusinessException(&quot;Error interno en búsqueda&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>