<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="originalContent" value="services:&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    container_name: user-api-postgres&#10;    environment:&#10;      POSTGRES_DB: ${DB_NAME}&#10;      POSTGRES_USER: ${DB_USERNAME}&#10;      POSTGRES_PASSWORD: ${DB_PASSWORD}&#10;      POSTGRES_INITDB_ARGS: &quot;--encoding=UTF-8&quot;&#10;    ports:&#10;      - &quot;${DB_PORT}:5432&quot;&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;    networks:&#10;      - user-api-network&#10;    restart: unless-stopped&#10;&#10;volumes:&#10;  postgres_data:&#10;&#10;networks:&#10;  user-api-network:&#10;    driver: bridge&#10;" />
              <option name="updatedContent" value="# ==========================================&#10;# DOCKER COMPOSE PARA DESARROLLO LOCAL&#10;# ==========================================&#10;# Este archivo es SOLO para desarrollo local&#10;# Railway NO lo usa - maneja servicios automáticamente&#10;# Para usar: docker-compose up -d&#10;# ==========================================&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    container_name: user-api-postgres&#10;    environment:&#10;      POSTGRES_DB: ${DB_NAME}&#10;      POSTGRES_USER: ${DB_USERNAME}&#10;      POSTGRES_PASSWORD: ${DB_PASSWORD}&#10;      POSTGRES_INITDB_ARGS: &quot;--encoding=UTF-8&quot;&#10;    ports:&#10;      - &quot;${DB_PORT}:5432&quot;&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;    networks:&#10;      - user-api-network&#10;    restart: unless-stopped&#10;&#10;volumes:&#10;  postgres_data:&#10;&#10;networks:&#10;  user-api-network:&#10;    driver: bridge" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/RailwayDataSourceConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/RailwayDataSourceConfig.java" />
              <option name="originalContent" value="package com.sordi.userManagement.config;&#10;&#10;import org.springframework.boot.context.properties.ConfigurationProperties;&#10;import org.springframework.boot.jdbc.DataSourceBuilder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.context.annotation.Primary;&#10;import org.springframework.context.annotation.Profile;&#10;&#10;import javax.sql.DataSource;&#10;import java.net.URI;&#10;import java.net.URISyntaxException;&#10;&#10;/**&#10; * Configuración profesional de DataSource para Railway&#10; *&#10; * Railway proporciona DATABASE_URL en formato: postgresql://user:pass@host:port/db&#10; * Spring Boot necesita: jdbc:postgresql://host:port/db&#10; *&#10; * Esta configuración maneja automáticamente la conversión sin requerir variables adicionales&#10; */&#10;@Configuration&#10;@Profile(&quot;prod&quot;)&#10;public class RailwayDataSourceConfig {&#10;&#10;    @Bean&#10;    @Primary&#10;    @ConfigurationProperties(&quot;spring.datasource.hikari&quot;)&#10;    public DataSource dataSource() {&#10;        String databaseUrl = System.getenv(&quot;DATABASE_URL&quot;);&#10;&#10;        if (databaseUrl != null &amp;&amp; databaseUrl.startsWith(&quot;postgresql://&quot;)) {&#10;            return createRailwayDataSource(databaseUrl);&#10;        }&#10;&#10;        // Fallback para desarrollo local (usa application-prod.yml)&#10;        return DataSourceBuilder.create().build();&#10;    }&#10;&#10;    @Bean&#10;    public Flyway flyway(DataSource dataSource) {&#10;        return Flyway.configure()&#10;                .dataSource(dataSource)&#10;                .locations(&quot;classpath:db/migration&quot;)&#10;                .table(&quot;flyway_schema_history&quot;)&#10;                .baselineOnMigrate(true)&#10;                .validateOnMigrate(true)&#10;                .cleanDisabled(true)&#10;                .load();&#10;    }&#10;&#10;    private DataSource createRailwayDataSource(String databaseUrl) {&#10;        try {&#10;            URI dbUri = new URI(databaseUrl);&#10;&#10;            String jdbcUrl = String.format(&#10;                &quot;jdbc:postgresql://%s:%d%s?sslmode=require&quot;,&#10;                dbUri.getHost(),&#10;                dbUri.getPort(),&#10;                dbUri.getPath()&#10;            );&#10;&#10;            String[] userInfo = dbUri.getUserInfo().split(&quot;:&quot;);&#10;            String username = userInfo[0];&#10;            String password = userInfo[1];&#10;&#10;            return DataSourceBuilder&#10;                    .create()&#10;                    .url(jdbcUrl)&#10;                    .username(username)&#10;                    .password(password)&#10;                    .driverClassName(&quot;org.postgresql.Driver&quot;)&#10;                    .build();&#10;&#10;        } catch (URISyntaxException e) {&#10;            throw new RuntimeException(&quot;Error parsing DATABASE_URL from Railway: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#13;&#10;&#13;&#10;import org.flywaydb.core.Flyway;&#13;&#10;import org.springframework.boot.context.properties.ConfigurationProperties;&#13;&#10;import org.springframework.boot.jdbc.DataSourceBuilder;&#13;&#10;import org.springframework.context.annotation.Bean;&#13;&#10;import org.springframework.context.annotation.Configuration;&#13;&#10;import org.springframework.context.annotation.Primary;&#13;&#10;import org.springframework.context.annotation.Profile;&#13;&#10;&#13;&#10;import javax.sql.DataSource;&#13;&#10;import java.net.URI;&#13;&#10;import java.net.URISyntaxException;&#13;&#10;&#13;&#10;/**&#13;&#10; * Configuración profesional de DataSource para Railway&#13;&#10; *&#13;&#10; * Railway proporciona DATABASE_URL en formato: postgresql://user:pass@host:port/db&#13;&#10; * Spring Boot necesita: jdbc:postgresql://host:port/db&#13;&#10; *&#13;&#10; * Esta configuración maneja automáticamente la conversión sin requerir variables adicionales&#13;&#10; */&#13;&#10;@Configuration&#13;&#10;@Profile(&quot;prod&quot;)&#13;&#10;public class RailwayDataSourceConfig {&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    @Primary&#13;&#10;    @ConfigurationProperties(&quot;spring.datasource.hikari&quot;)&#13;&#10;    public DataSource dataSource() {&#13;&#10;        String databaseUrl = System.getenv(&quot;DATABASE_URL&quot;);&#13;&#10;&#13;&#10;        if (databaseUrl != null &amp;&amp; databaseUrl.startsWith(&quot;postgresql://&quot;)) {&#13;&#10;            return createRailwayDataSource(databaseUrl);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Fallback para desarrollo local (usa application-prod.yml)&#13;&#10;        return DataSourceBuilder.create().build();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public Flyway flyway(DataSource dataSource) {&#13;&#10;        return Flyway.configure()&#13;&#10;                .dataSource(dataSource)&#13;&#10;                .locations(&quot;classpath:db/migration&quot;)&#13;&#10;                .table(&quot;flyway_schema_history&quot;)&#13;&#10;                .baselineOnMigrate(true)&#13;&#10;                .validateOnMigrate(true)&#13;&#10;                .cleanDisabled(true)&#13;&#10;                .load();&#13;&#10;    }&#13;&#10;&#13;&#10;    private DataSource createRailwayDataSource(String databaseUrl) {&#13;&#10;        try {&#13;&#10;            URI dbUri = new URI(databaseUrl);&#13;&#10;&#13;&#10;            String jdbcUrl = String.format(&#13;&#10;                &quot;jdbc:postgresql://%s:%d%s?sslmode=require&quot;,&#13;&#10;                dbUri.getHost(),&#13;&#10;                dbUri.getPort(),&#13;&#10;                dbUri.getPath()&#13;&#10;            );&#13;&#10;&#13;&#10;            String[] userInfo = dbUri.getUserInfo().split(&quot;:&quot;);&#13;&#10;            String username = userInfo[0];&#13;&#10;            String password = userInfo[1];&#13;&#10;&#13;&#10;            return DataSourceBuilder&#13;&#10;                    .create()&#13;&#10;                    .url(jdbcUrl)&#13;&#10;                    .username(username)&#13;&#10;                    .password(password)&#13;&#10;                    .driverClassName(&quot;org.postgresql.Driver&quot;)&#13;&#10;                    .build();&#13;&#10;&#13;&#10;        } catch (URISyntaxException e) {&#13;&#10;            throw new RuntimeException(&quot;Error parsing DATABASE_URL from Railway: &quot; + e.getMessage(), e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.interceptor.TokenRefreshInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Configuración de interceptores HTTP&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final TokenRefreshInterceptor tokenRefreshInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(tokenRefreshInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Aplicar a todas las rutas de la API&#10;                .excludePathPatterns(&#10;                    &quot;/api/auth/login&quot;,&#10;                    &quot;/api/auth/register&quot;, &#10;                    &quot;/api/auth/refresh&quot;&#10;                ); // Excluir endpoints públicos&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.interceptor;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.sordi.userManagement.model.dto.response.TokenExpiredResponse;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import io.jsonwebtoken.ExpiredJwtException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.servlet.HandlerInterceptor;&#10;&#10;/**&#10; * Interceptor para manejar automáticamente la renovación de tokens&#10; * Se ejecuta ANTES de que llegue al controlador&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class TokenRefreshInterceptor implements HandlerInterceptor {&#10;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;&#10;    @Override&#10;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {&#10;        &#10;        // Solo procesar rutas que requieren autenticación (excluir /auth/login, /auth/register, etc.)&#10;        String requestURI = request.getRequestURI();&#10;        if (isPublicEndpoint(requestURI)) {&#10;            return true; // Continuar sin validar token&#10;        }&#10;&#10;        String jwt = extractTokenFromRequest(request);&#10;        &#10;        if (jwt != null) {&#10;            try {&#10;                // Si el token es válido, continuar normalmente&#10;                if (jwtTokenProvider.validateToken(jwt)) {&#10;                    return true;&#10;                }&#10;            } catch (ExpiredJwtException ex) {&#10;                // Token expirado - enviar respuesta específica&#10;                log.info(&quot;Token expirado detectado en interceptor para usuario: {}&quot;, ex.getClaims().getSubject());&#10;                sendTokenExpiredResponse(response);&#10;                return false; // Detener procesamiento&#10;            }&#10;        }&#10;        &#10;        return true; // Continuar si no hay token o token inválido (lo manejará el filtro de seguridad)&#10;    }&#10;&#10;    /**&#10;     * Verifica si el endpoint es público (no requiere autenticación)&#10;     */&#10;    private boolean isPublicEndpoint(String requestURI) {&#10;        return requestURI.startsWith(&quot;/api/auth/login&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/register&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/refresh&quot;) ||&#10;               requestURI.startsWith(&quot;/actuator&quot;) ||&#10;               requestURI.startsWith(&quot;/swagger&quot;) ||&#10;               requestURI.startsWith(&quot;/v3/api-docs&quot;);&#10;    }&#10;&#10;    /**&#10;     * Extrae el token del header Authorization&#10;     */&#10;    private String extractTokenFromRequest(HttpServletRequest request) {&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            return bearerToken.substring(7);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Envía respuesta JSON indicando que el token expiró&#10;     */&#10;    private void sendTokenExpiredResponse(HttpServletResponse response) throws Exception {&#10;        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);&#10;        response.setContentType(&quot;application/json&quot;);&#10;        response.setCharacterEncoding(&quot;UTF-8&quot;);&#10;&#10;        TokenExpiredResponse expiredResponse = TokenExpiredResponse.createRefreshRequired();&#10;        String jsonResponse = objectMapper.writeValueAsString(expiredResponse);&#10;        &#10;        response.getWriter().write(jsonResponse);&#10;        response.getWriter().flush();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10; * DTO para actualización de usuario por parte del administrador.&#10; * Incluye campos que solo admin puede modificar como isActive.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Schema(description = &quot;Request para actualización de usuario por administrador&quot;)&#10;public class AdminUpdateUserRequest {&#10;&#10;    @Schema(description = &quot;Nombre del usuario&quot;, example = &quot;Juan&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El nombre debe tener entre 2 y 50 caracteres&quot;)&#10;    private String firstName;&#10;&#10;    @Schema(description = &quot;Apellido del usuario&quot;, example = &quot;Pérez&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El apellido debe tener entre 2 y 50 caracteres&quot;)&#10;    private String lastName;&#10;&#10;    @Schema(description = &quot;Email del usuario&quot;, example = &quot;juan.perez@email.com&quot;)&#10;    @Email(message = &quot;Formato de email inválido&quot;)&#10;    private String email;&#10;&#10;    @Schema(description = &quot;Estado activo del usuario&quot;, example = &quot;true&quot;)&#10;    private Boolean isActive; // ✅ Solo admin puede cambiar esto&#10;&#10;    @Schema(description = &quot;Rol del usuario&quot;, example = &quot;USER&quot;)&#10;    private String role; // ✅ Solo admin puede cambiar roles&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/config/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/config/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta config (configuraciones de test)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/fixtures/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/fixtures/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta fixtures (datos de prueba reutilizables)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/controller/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/controller/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta integration/controller" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/repository/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/repository/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta integration/repository" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/security/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/security/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta unit/security" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/.gitkeep" />
              <option name="updatedContent" value="// Archivo marcador para crear la estructura de carpetas unit/service/&#10;// Este archivo se puede eliminar después de crear los tests reales" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/AuthServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/AuthServiceTest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import com.sordi.userManagement.service.AuthService;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para AuthService&#10; *&#10; * ESTRUCTURA:&#10; * - Tests de Login: Autenticación de usuarios&#10; * - Tests de Register: Registro de nuevos usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de AuthService&quot;)&#10;public class AuthServiceTest {&#10;&#10;    @Mock&#10;    private UserRepository userRepository;&#10;&#10;    @Mock&#10;    private UserMapper userMapper;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    @Mock&#10;    private AuthenticationManager authenticationManager;&#10;&#10;    @Mock&#10;    private JwtTokenProvider jwtTokenProvider;&#10;&#10;    @Mock&#10;    private JwtConfig jwtConfig;&#10;&#10;    @Mock&#10;    private User mockUser; // ← Agregar @Mock aquí&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS&#10;    private LoginRequest validLoginRequest;&#10;    private CreateUserRequest validRegisterRequest;&#10;    private UserResponse mockUserResponse;&#10;    private Authentication mockAuthentication;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Configuración básica compartida&#10;        //Login&#10;        validLoginRequest = new LoginRequest();&#10;        validLoginRequest.setUsername(&quot;johndoe&quot;);&#10;        validLoginRequest.setPassword(&quot;password123&quot;);&#10;&#10;        // mockUser = UserFixtures.createBasicUser(); ← Eliminar esta línea&#10;&#10;        // Register&#10;        validRegisterRequest = UserFixtures.createValidCreateUserRequest();&#10;        mockUserResponse = UserFixtures.createUserResponse();&#10;        mockAuthentication = mock(Authentication.class);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE LOGIN&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Login&quot;)&#10;    class LoginTests {&#10;&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería autenticar usuario exitosamente con credenciales válidas&quot;)&#10;        void deberiaAutenticarUsuario_CuandoLasCredencialesSonValidas() {&#10;            // PREPARAR: Configurar mocks para login exitoso&#10;            String expectedToken = &quot;jwt.token.aqui&quot;;&#10;            String expectedRefreshToken = &quot;jwt.token.refresh.aqui&quot;;&#10;            String username = &quot;johndoe&quot;;&#10;&#10;            // Mock para AuthenticationManager&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenReturn(mockAuthentication);&#10;&#10;            // Mock para UserRepository - CRÍTICO: debe devolver el usuario&#10;            when(userRepository.findByUsername(username)).thenReturn(Optional.of(mockUser));&#10;            when(mockUser.getUsername()).thenReturn(username); // Esto es lo que realmente usa el código&#10;&#10;            // Mock para JwtTokenProvider&#10;            when(jwtTokenProvider.generateToken(username)).thenReturn(expectedToken);&#10;            when(jwtTokenProvider.generateRefreshToken(username)).thenReturn(expectedRefreshToken);&#10;&#10;            // Mock para JwtConfig&#10;            when(jwtConfig.getExpirationInSeconds()).thenReturn(3600L);&#10;&#10;            // EJECUTAR: Intentar login&#10;            JwtResponse response = authService.login(validLoginRequest);&#10;&#10;            // VERIFICAR: Login exitoso&#10;            assertNotNull(response, &quot;La respuesta no debería ser null&quot;);&#10;            assertEquals(expectedToken, response.getAccessToken(), &quot;El access token debería coincidir&quot;);&#10;            assertEquals(expectedRefreshToken, response.getRefreshToken(), &quot;El refresh token debería coincidir&quot;);&#10;            assertEquals(&quot;Bearer&quot;, response.getTokenType(), &quot;El tipo debería ser Bearer&quot;);&#10;            assertEquals(3600L, response.getExpiresIn(), &quot;La expiración debería coincidir&quot;);&#10;            assertNotNull(response.getIssuedAt(), &quot;Debería tener fecha de emisión&quot;);&#10;&#10;            // VERIFICAR: Que se llamaron los métodos correctos&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(userRepository).findByUsername(username);&#10;            verify(jwtTokenProvider).generateToken(username);&#10;            verify(jwtTokenProvider).generateRefreshToken(username);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción con credenciales incorrectas&quot;)&#10;        void deberiaLanzarExcepcion_CuandoLasCredencialesSonIncorrectas() {&#10;            // PREPARAR: Simular credenciales incorrectas&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenThrow(new BadCredentialsException(&quot;Credenciales inválidas&quot;));&#10;&#10;            // EJECUTAR Y VERIFICAR: Debe fallar la autenticación&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.login(validLoginRequest),&#10;                &quot;Debería lanzar BusinessException con credenciales incorrectas&quot;&#10;            );&#10;&#10;            assertTrue(exception.getMessage().contains(&quot;Credenciales inválidas&quot;));&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Login con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.login(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de login son requeridos&quot;, exception.getMessage());&#10;            verify(authenticationManager, never()).authenticate(any());&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE REGISTER&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Register&quot;)&#10;    class RegisterTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería registrar usuario exitosamente&quot;)&#10;        void deberiaRegistrarUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mock de UserService&#10;            when(userRepository.existsByEmail(validRegisterRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByUsername(validRegisterRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByDni(validRegisterRequest.getDni())).thenReturn(false);&#10;&#10;            when(userMapper.toEntity(validRegisterRequest)).thenReturn(mockUser);&#10;            when(passwordEncoder.encode(validRegisterRequest.getPassword())).thenReturn(&quot;encodedPassword&quot;);&#10;            when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockUserResponse);&#10;&#10;            //  EJECUTAR: Registrar usuario&#10;            UserResponse result = authService.register(validRegisterRequest);&#10;&#10;            //  VERIFICAR: Registro exitoso&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockUserResponse.getUsername(), result.getUsername());&#10;            assertEquals(mockUserResponse.getEmail(), result.getEmail());&#10;&#10;            verify(userRepository).existsByEmail(validRegisterRequest.getEmail());&#10;            verify(userRepository).existsByUsername(validRegisterRequest.getUsername());&#10;            verify(userRepository).existsByDni(validRegisterRequest.getDni());&#10;&#10;            verify(userMapper).toEntity(validRegisterRequest);&#10;            verify(passwordEncoder).encode(validRegisterRequest.getPassword());&#10;&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería propagar BusinessException del UserService&quot;)&#10;        void deberiaPropagar_BusinessExceptionDelUserService() {&#10;            //  PREPARAR: UserService lanza excepción (ej: email duplicado)&#10;            when(authService.register(validRegisterRequest))&#10;                .thenThrow(new BusinessException(&quot;Email ya esta en uso&quot;));&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe propagar la excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.register(validRegisterRequest), // Corregido: era userService.createUser()&#10;                &quot;Debería propagar BusinessException del UserService&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(authService).register(validRegisterRequest);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            //  EJECUTAR Y VERIFICAR: Register con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.register(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de registro son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).existsByEmail(any());&#10;            verify(userRepository, never()).existsByUsername(any());&#10;            verify(userRepository, never()).existsByDni(any());&#10;            verify(userMapper, never()).toEntity(any());&#10;            verify(passwordEncoder, never()).encode(any());&#10;            verify(userRepository, never()).save(any());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.config.JwtConfig;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import com.sordi.userManagement.service.AuthService;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para AuthService&#10; *&#10; * ESTRUCTURA:&#10; * - Tests de Login: Autenticación de usuarios&#10; * - Tests de Register: Registro de nuevos usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de AuthService&quot;)&#10;public class AuthServiceTest {&#10;&#10;    @Mock&#10;    private UserRepository userRepository;&#10;&#10;    @Mock&#10;    private UserMapper userMapper;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    @Mock&#10;    private AuthenticationManager authenticationManager;&#10;&#10;    @Mock&#10;    private JwtTokenProvider jwtTokenProvider;&#10;&#10;    @Mock&#10;    private JwtConfig jwtConfig;&#10;&#10;    @Mock&#10;    private User mockUser; // ← Agregar @Mock aquí&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS&#10;    private LoginRequest validLoginRequest;&#10;    private CreateUserRequest validRegisterRequest;&#10;    private UserResponse mockUserResponse;&#10;    private Authentication mockAuthentication;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Configuración básica compartida&#10;        //Login&#10;        validLoginRequest = new LoginRequest();&#10;        validLoginRequest.setUsername(&quot;johndoe&quot;);&#10;        validLoginRequest.setPassword(&quot;password123&quot;);&#10;&#10;        // mockUser = UserFixtures.createBasicUser(); ← Eliminar esta línea&#10;&#10;        // Register&#10;        validRegisterRequest = UserFixtures.createValidCreateUserRequest();&#10;        mockUserResponse = UserFixtures.createUserResponse();&#10;        mockAuthentication = mock(Authentication.class);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE LOGIN&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Login&quot;)&#10;    class LoginTests {&#10;&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería autenticar usuario exitosamente con credenciales válidas&quot;)&#10;        void deberiaAutenticarUsuario_CuandoLasCredencialesSonValidas() {&#10;            // PREPARAR: Configurar mocks para login exitoso&#10;            String expectedToken = &quot;jwt.token.aqui&quot;;&#10;            String expectedRefreshToken = &quot;jwt.token.refresh.aqui&quot;;&#10;            String username = &quot;johndoe&quot;;&#10;&#10;            // Mock para AuthenticationManager&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenReturn(mockAuthentication);&#10;&#10;            // Mock para UserRepository - CRÍTICO: debe devolver el usuario&#10;            when(userRepository.findByUsername(username)).thenReturn(Optional.of(mockUser));&#10;            when(mockUser.getUsername()).thenReturn(username); // Esto es lo que realmente usa el código&#10;&#10;            // Mock para JwtTokenProvider&#10;            when(jwtTokenProvider.generateToken(username)).thenReturn(expectedToken);&#10;            when(jwtTokenProvider.generateRefreshToken(username)).thenReturn(expectedRefreshToken);&#10;&#10;            // Mock para JwtConfig&#10;            when(jwtConfig.getExpirationInSeconds()).thenReturn(3600L);&#10;&#10;            // EJECUTAR: Intentar login&#10;            JwtResponse response = authService.login(validLoginRequest);&#10;&#10;            // VERIFICAR: Login exitoso&#10;            assertNotNull(response, &quot;La respuesta no debería ser null&quot;);&#10;            assertEquals(expectedToken, response.getAccessToken(), &quot;El access token debería coincidir&quot;);&#10;            assertEquals(expectedRefreshToken, response.getRefreshToken(), &quot;El refresh token debería coincidir&quot;);&#10;            assertEquals(&quot;Bearer&quot;, response.getTokenType(), &quot;El tipo debería ser Bearer&quot;);&#10;            assertEquals(3600L, response.getExpiresIn(), &quot;La expiración debería coincidir&quot;);&#10;            assertNotNull(response.getIssuedAt(), &quot;Debería tener fecha de emisión&quot;);&#10;&#10;            // VERIFICAR: Que se llamaron los métodos correctos&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(userRepository).findByUsername(username);&#10;            verify(jwtTokenProvider).generateToken(username);&#10;            verify(jwtTokenProvider).generateRefreshToken(username);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción con credenciales incorrectas&quot;)&#10;        void deberiaLanzarExcepcion_CuandoLasCredencialesSonIncorrectas() {&#10;            // PREPARAR: Simular credenciales incorrectas&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenThrow(new BadCredentialsException(&quot;Credenciales inválidas&quot;));&#10;&#10;            // EJECUTAR Y VERIFICAR: Debe fallar la autenticación&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.login(validLoginRequest),&#10;                &quot;Debería lanzar BusinessException con credenciales incorrectas&quot;&#10;            );&#10;&#10;            assertTrue(exception.getMessage().contains(&quot;Credenciales inválidas&quot;));&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Login con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.login(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de login son requeridos&quot;, exception.getMessage());&#10;            verify(authenticationManager, never()).authenticate(any());&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE REGISTER&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Register&quot;)&#10;    class RegisterTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería registrar usuario exitosamente&quot;)&#10;        void deberiaRegistrarUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mock de UserService&#10;            when(userRepository.existsByEmail(validRegisterRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByUsername(validRegisterRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByDni(validRegisterRequest.getDni())).thenReturn(false);&#10;&#10;            when(userMapper.toEntity(validRegisterRequest)).thenReturn(mockUser);&#10;            when(passwordEncoder.encode(validRegisterRequest.getPassword())).thenReturn(&quot;encodedPassword&quot;);&#10;            when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockUserResponse);&#10;&#10;            //  EJECUTAR: Registrar usuario&#10;            UserResponse result = authService.register(validRegisterRequest);&#10;&#10;            //  VERIFICAR: Registro exitoso&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockUserResponse.getUsername(), result.getUsername());&#10;            assertEquals(mockUserResponse.getEmail(), result.getEmail());&#10;&#10;            verify(userRepository).existsByEmail(validRegisterRequest.getEmail());&#10;            verify(userRepository).existsByUsername(validRegisterRequest.getUsername());&#10;            verify(userRepository).existsByDni(validRegisterRequest.getDni());&#10;&#10;            verify(userMapper).toEntity(validRegisterRequest);&#10;            verify(passwordEncoder).encode(validRegisterRequest.getPassword());&#10;&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando email ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoEmailYaExiste() {&#10;            // PREPARAR: Simular que el email ya existe&#10;            when(userRepository.existsByEmail(validRegisterRequest.getEmail())).thenReturn(true);&#10;&#10;            // EJECUTAR Y VERIFICAR: Debe lanzar excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.register(validRegisterRequest),&#10;                &quot;Debería lanzar BusinessException cuando email ya existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(userRepository).existsByEmail(validRegisterRequest.getEmail());&#10;            // Verificar que NO se llamaron otros métodos después de la validación&#10;            verify(userRepository, never()).existsByUsername(any());&#10;            verify(userRepository, never()).existsByDni(any());&#10;            verify(userMapper, never()).toEntity(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            //  EJECUTAR Y VERIFICAR: Register con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.register(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de registro son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).existsByEmail(any());&#10;            verify(userRepository, never()).existsByUsername(any());&#10;            verify(userRepository, never()).existsByDni(any());&#10;            verify(userMapper, never()).toEntity(any());&#10;            verify(passwordEncoder, never()).encode(any());&#10;            verify(userRepository, never()).save(any());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>