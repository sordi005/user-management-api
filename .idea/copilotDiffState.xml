<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# =================================================&#10;# Variables de Entorno para User Management API&#10;# =================================================&#10;# IMPORTANTE: Este archivo NO se sube a GitHub&#10;# Cópialo como .env y configura tus valores&#10;&#10;# =================================================&#10;# BASE DE DATOS POSTGRESQL&#10;# =================================================&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=user_management&#10;DB_USERNAME=sordi005&#10;DB_PASSWORD=dev123&#10;&#10;# =================================================&#10;# PGADMIN (Herramienta gráfica para PostgreSQL)&#10;# =================================================&#10;PGADMIN_EMAIL=admin@example.com&#10;PGADMIN_PASSWORD=admin123&#10;PGADMIN_PORT=5050&#10;&#10;# =================================================&#10;# APLICACIÓN SPRING BOOT&#10;# =================================================&#10;SERVER_PORT=8086&#10;SPRING_PROFILE=dev&#10;&#10;# =================================================&#10;# JWT (JSON Web Tokens)&#10;# =================================================&#10;JWT_SECRET=mi_super_secreto_jwt_key_debe_tener_minimo_32_caracteres_para_ser_seguro&#10;JWT_EXPIRATION_MS=86400000&#10;&#10;# =================================================&#10;# LOGGING&#10;# =================================================&#10;LOG_LEVEL_APP=DEBUG&#10;LOG_LEVEL_SECURITY=DEBUG&#10;SHOW_SQL=true&#10;&#10;# =================================================&#10;# ACTUATOR (Monitoring)&#10;# =================================================&#10;ACTUATOR_ENDPOINTS=health,info,metrics" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/query-methods-reference.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/query-methods-reference.md" />
              <option name="updatedContent" value="# Spring Data JPA Query Methods Reference&#10;&#10;## Palabras Clave Principales&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `find...By` | Buscar registros | `findByEmail(String email)` |&#10;| `get...By` | Alias para find | `getByUsername(String username)` |&#10;| `query...By` | Alias para find | `queryByFirstName(String name)` |&#10;| `count...By` | Contar registros | `countByActive(Boolean active)` |&#10;| `exists...By` | Verificar existencia | `existsByEmail(String email)` |&#10;| `delete...By` | Eliminar registros | `deleteByUsername(String username)` |&#10;| `remove...By` | Alias para delete | `removeByEmail(String email)` |&#10;&#10;## Operadores Lógicos&#10;&#10;| Operador | SQL Equivalente | Ejemplo |&#10;|----------|-----------------|---------|&#10;| `And` | `AND` | `findByFirstNameAndLastName(String first, String last)` |&#10;| `Or` | `OR` | `findByEmailOrUsername(String email, String username)` |&#10;| `Not` | `NOT` | `findByActiveNot(Boolean active)` |&#10;&#10;## Comparadores&#10;&#10;| Comparador | SQL Equivalente | Ejemplo |&#10;|------------|-----------------|---------|&#10;| `IsNull` | `IS NULL` | `findByEmailIsNull()` |&#10;| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull()` |&#10;| `Like` | `LIKE` | `findByFirstNameLike(String pattern)` |&#10;| `NotLike` | `NOT LIKE` | `findByFirstNameNotLike(String pattern)` |&#10;| `StartingWith` | `LIKE 'value%'` | `findByEmailStartingWith(String prefix)` |&#10;| `EndingWith` | `LIKE '%value'` | `findByEmailEndingWith(String suffix)` |&#10;| `Containing` | `LIKE '%value%'` | `findByFirstNameContaining(String substring)` |&#10;| `IgnoreCase` | `UPPER()` | `findByEmailIgnoreCase(String email)` |&#10;| `GreaterThan` | `&gt;` | `findByAgeGreaterThan(Integer age)` |&#10;| `LessThan` | `&lt;` | `findByAgeLessThan(Integer age)` |&#10;| `Between` | `BETWEEN` | `findByAgeBetween(Integer start, Integer end)` |&#10;| `In` | `IN` | `findByUsernameIn(Collection&lt;String&gt; usernames)` |&#10;&#10;## Ordenamiento y Limitación&#10;&#10;| Palabra Clave | Descripción | Ejemplo |&#10;|---------------|-------------|---------|&#10;| `OrderBy...Asc` | Ordenar ascendente | `findByActiveOrderByUsernameAsc(Boolean active)` |&#10;| `OrderBy...Desc` | Ordenar descendente | `findByActiveOrderByCreatedAtDesc(Boolean active)` |&#10;| `Top` | Limitar resultados | `findTop10ByActive(Boolean active)` |&#10;| `First` | Primer resultado | `findFirstByOrderByCreatedAtDesc()` |&#10;| `Distinct` | Resultados únicos | `findDistinctByLastName(String lastName)` |" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/setup-env-windows.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/setup-env-windows.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo   Configurando Variables de Entorno&#10;echo   para User Management API&#10;echo ========================================&#10;&#10;REM Base de Datos&#10;set DB_HOST=localhost&#10;set DB_PORT=5432&#10;set DB_NAME=user_management&#10;set DB_USERNAME=dev_user&#10;set DB_PASSWORD=dev123&#10;&#10;REM JWT&#10;set JWT_SECRET=mi_super_secreto_jwt_key_de_32_caracteres_minimo&#10;set JWT_EXPIRATION_MS=86400000&#10;&#10;REM Logging&#10;set LOG_LEVEL_APP=DEBUG&#10;set LOG_LEVEL_SECURITY=DEBUG&#10;set SHOW_SQL=true&#10;&#10;REM Actuator&#10;set ACTUATOR_ENDPOINTS=health,info,metrics&#10;&#10;echo.&#10;echo ✅ Variables configuradas para esta sesión&#10;echo.&#10;echo Para hacerlas permanentes:&#10;echo 1. Panel de Control ^&gt; Sistema ^&gt; Variables de entorno&#10;echo 2. O usar: setx VARIABLE_NAME &quot;valor&quot;&#10;echo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/config/WebConfig.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.config;&#10;&#10;import com.sordi.userManagement.interceptor.TokenRefreshInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Configuración de interceptores HTTP&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final TokenRefreshInterceptor tokenRefreshInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(tokenRefreshInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Aplicar a todas las rutas de la API&#10;                .excludePathPatterns(&#10;                    &quot;/api/auth/login&quot;,&#10;                    &quot;/api/auth/register&quot;, &#10;                    &quot;/api/auth/refresh&quot;&#10;                ); // Excluir endpoints públicos&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/interceptor/TokenRefreshInterceptor.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.interceptor;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.sordi.userManagement.model.dto.response.TokenExpiredResponse;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import io.jsonwebtoken.ExpiredJwtException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.servlet.HandlerInterceptor;&#10;&#10;/**&#10; * Interceptor para manejar automáticamente la renovación de tokens&#10; * Se ejecuta ANTES de que llegue al controlador&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class TokenRefreshInterceptor implements HandlerInterceptor {&#10;&#10;    private final JwtTokenProvider jwtTokenProvider;&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;&#10;    @Override&#10;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {&#10;        &#10;        // Solo procesar rutas que requieren autenticación (excluir /auth/login, /auth/register, etc.)&#10;        String requestURI = request.getRequestURI();&#10;        if (isPublicEndpoint(requestURI)) {&#10;            return true; // Continuar sin validar token&#10;        }&#10;&#10;        String jwt = extractTokenFromRequest(request);&#10;        &#10;        if (jwt != null) {&#10;            try {&#10;                // Si el token es válido, continuar normalmente&#10;                if (jwtTokenProvider.validateToken(jwt)) {&#10;                    return true;&#10;                }&#10;            } catch (ExpiredJwtException ex) {&#10;                // Token expirado - enviar respuesta específica&#10;                log.info(&quot;Token expirado detectado en interceptor para usuario: {}&quot;, ex.getClaims().getSubject());&#10;                sendTokenExpiredResponse(response);&#10;                return false; // Detener procesamiento&#10;            }&#10;        }&#10;        &#10;        return true; // Continuar si no hay token o token inválido (lo manejará el filtro de seguridad)&#10;    }&#10;&#10;    /**&#10;     * Verifica si el endpoint es público (no requiere autenticación)&#10;     */&#10;    private boolean isPublicEndpoint(String requestURI) {&#10;        return requestURI.startsWith(&quot;/api/auth/login&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/register&quot;) ||&#10;               requestURI.startsWith(&quot;/api/auth/refresh&quot;) ||&#10;               requestURI.startsWith(&quot;/actuator&quot;) ||&#10;               requestURI.startsWith(&quot;/swagger&quot;) ||&#10;               requestURI.startsWith(&quot;/v3/api-docs&quot;);&#10;    }&#10;&#10;    /**&#10;     * Extrae el token del header Authorization&#10;     */&#10;    private String extractTokenFromRequest(HttpServletRequest request) {&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            return bearerToken.substring(7);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Envía respuesta JSON indicando que el token expiró&#10;     */&#10;    private void sendTokenExpiredResponse(HttpServletResponse response) throws Exception {&#10;        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);&#10;        response.setContentType(&quot;application/json&quot;);&#10;        response.setCharacterEncoding(&quot;UTF-8&quot;);&#10;&#10;        TokenExpiredResponse expiredResponse = TokenExpiredResponse.createRefreshRequired();&#10;        String jsonResponse = objectMapper.writeValueAsString(expiredResponse);&#10;        &#10;        response.getWriter().write(jsonResponse);&#10;        response.getWriter().flush();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/AdminUpdateUserRequest.java" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10; * DTO para actualización de usuario por parte del administrador.&#10; * Incluye campos que solo admin puede modificar como isActive.&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Schema(description = &quot;Request para actualización de usuario por administrador&quot;)&#10;public class AdminUpdateUserRequest {&#10;&#10;    @Schema(description = &quot;Nombre del usuario&quot;, example = &quot;Juan&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El nombre debe tener entre 2 y 50 caracteres&quot;)&#10;    private String firstName;&#10;&#10;    @Schema(description = &quot;Apellido del usuario&quot;, example = &quot;Pérez&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;El apellido debe tener entre 2 y 50 caracteres&quot;)&#10;    private String lastName;&#10;&#10;    @Schema(description = &quot;Email del usuario&quot;, example = &quot;juan.perez@email.com&quot;)&#10;    @Email(message = &quot;Formato de email inválido&quot;)&#10;    private String email;&#10;&#10;    @Schema(description = &quot;Estado activo del usuario&quot;, example = &quot;true&quot;)&#10;    private Boolean isActive; // ✅ Solo admin puede cambiar esto&#10;&#10;    @Schema(description = &quot;Rol del usuario&quot;, example = &quot;USER&quot;)&#10;    private String role; // ✅ Solo admin puede cambiar roles&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/CreateUser.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public class CreateUser {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 3, max = 50)&#10;    private String lastName;&#10;&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private String dateOfBirth; // Format: YYYY-MM-DD&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Size(min = 7, max = 10, message = &quot;DNI must be between 7 and 10 characters&quot;)&#10;    private String dni;&#10;&#10;    @Email&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 50, message = &quot;Username must be between 3 and 50 characters&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 6, max = 100, message = &quot;Password must be between 6 and 100 characters&quot;)&#10;    private String password;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import jakarta.validation.constraints.Past;&#10;import jakarta.validation.constraints.Pattern;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;/**&#10; * DTO for creating a new user.&#10; * Contains all required information for user registration.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateUserRequest {&#10;&#10;    @NotBlank(message = &quot;First name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;First name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;First name can only contain letters and spaces&quot;)&#10;    private String firstName;&#10;&#10;    @NotBlank(message = &quot;Last name is required&quot;)&#10;    @Size(min = 2, max = 50, message = &quot;Last name must be between 2 and 50 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]+$&quot;, message = &quot;Last name can only contain letters and spaces&quot;)&#10;    private String lastName;&#10;&#10;    @NotNull(message = &quot;Date of birth is required&quot;)&#10;    @Past(message = &quot;Date of birth must be in the past&quot;)&#10;    private LocalDate dateOfBirth;&#10;&#10;    @NotBlank(message = &quot;DNI is required&quot;)&#10;    @Pattern(regexp = &quot;^[0-9]{7,10}$&quot;, message = &quot;DNI must be between 7 and 10 digits&quot;)&#10;    private String dni;&#10;&#10;    @NotBlank(message = &quot;Email is required&quot;)&#10;    @Email(message = &quot;Invalid email format&quot;)&#10;    @Size(max = 100, message = &quot;Email must be less than 100 characters&quot;)&#10;    private String email;&#10;&#10;    @NotBlank(message = &quot;Username is required&quot;)&#10;    @Size(min = 3, max = 30, message = &quot;Username must be between 3 and 30 characters&quot;)&#10;    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;Username can only contain letters, numbers and underscores&quot;)&#10;    private String username;&#10;&#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    @Size(min = 8, max = 100, message = &quot;Password must be between 8 and 100 characters&quot;)&#10;    @Pattern(&#10;        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,&#10;        message = &quot;Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character&quot;&#10;    )&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sordi/userManagement/model/dto/request/loguinRequest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class loguinRequest {&#10;    private String username;&#10;    private String password;&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.model.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * DTO for user authentication (login).&#10; * Contains credentials required for user login.&#10; * &#10; * @author Santiago Sordi&#10; * @version 1.0&#10; */&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class LoginRequest {&#10;    &#10;    @NotBlank(message = &quot;Username or email is required&quot;)&#10;    private String usernameOrEmail;&#10;    &#10;    @NotBlank(message = &quot;Password is required&quot;)&#10;    private String password;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=user-management-api&#10;server.port=8085&#10;" />
              <option name="updatedContent" value="spring.application.name=user-management-api&#10;server.port=8086" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/config/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/config/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta config (configuraciones de test)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/fixtures/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/fixtures/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta fixtures (datos de prueba reutilizables)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/controller/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/controller/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta integration/controller" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/repository/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/integration/repository/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta integration/repository" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/security/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/security/.gitkeep" />
              <option name="updatedContent" value="// Marcador para carpeta unit/security" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/.gitkeep">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/.gitkeep" />
              <option name="updatedContent" value="// Archivo marcador para crear la estructura de carpetas unit/service/&#10;// Este archivo se puede eliminar después de crear los tests reales" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/AuthServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/AuthServiceTest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import com.sordi.userManagement.service.AuthService;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para AuthService&#10; *&#10; * ESTRUCTURA:&#10; * - Tests de Login: Autenticación de usuarios&#10; * - Tests de Register: Registro de nuevos usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de AuthService&quot;)&#10;public class AuthServiceTest {&#10;&#10;    @Mock&#10;    private AuthenticationManager authenticationManager;&#10;&#10;    @Mock&#10;    private UserService userService;&#10;&#10;    @Mock&#10;    private JwtTokenProvider jwtTokenProvider;&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS&#10;    private LoginRequest validLoginRequest;&#10;    private CreateUserRequest validRegisterRequest;&#10;    private UserResponse mockUserResponse;&#10;    private Authentication mockAuthentication;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Configuración básica compartida&#10;        //Login&#10;        validLoginRequest = new LoginRequest();&#10;        validLoginRequest.setUsername(&quot;johndoe&quot;);&#10;        validLoginRequest.setPassword(&quot;password123&quot;);&#10;&#10;        // Register&#10;        validRegisterRequest = UserFixtures.createValidCreateUserRequest();&#10;        mockUserResponse = UserFixtures.createUserResponse();&#10;        mockAuthentication = mock(Authentication.class);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE LOGIN&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Login&quot;)&#10;    class LoginTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot; Debería autenticar usuario exitosamente con credenciales válidas&quot;)&#10;        void deberiaAutenticarUsuario_CuandoLasCredencialesSonValidas() {&#10;            // PREPARAR: Configurar mocks para login exitoso&#10;            String expectedToken = &quot;jwt.token.aqui&quot;;&#10;&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenReturn(mockAuthentication);&#10;            when(jwtTokenProvider.generateToken(mockAuthentication))&#10;                .thenReturn(expectedToken);&#10;&#10;            // EJECUTAR: Intentar login&#10;            JwtResponse response = authService.login(validLoginRequest);&#10;&#10;            // VERIFICAR: Login exitoso&#10;            assertNotNull(response, &quot;La respuesta no debería ser null&quot;);&#10;            assertEquals(expectedToken, response.getAccessToken(), &quot;El token debería coincidir&quot;);&#10;            assertEquals(&quot;Bearer&quot;, response.getTokenType(), &quot;El tipo debería ser Bearer&quot;);&#10;&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider).generateToken(mockAuthentication);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción con credenciales incorrectas&quot;)&#10;        void deberiaLanzarExcepcion_CuandoLasCredencialesSonIncorrectas() {&#10;            // PREPARAR: Simular credenciales incorrectas&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenThrow(new BadCredentialsException(&quot;Credenciales inválidas&quot;));&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe fallar la autenticación&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.login(validLoginRequest),&#10;                &quot;Debería lanzar BusinessException con credenciales incorrectas&quot;&#10;            );&#10;&#10;            assertTrue(exception.getMessage().contains(&quot;Credenciales inválidas&quot;));&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Login con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.login(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de login son requeridos&quot;, exception.getMessage());&#10;            verify(authenticationManager, never()).authenticate(any());&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE REGISTER&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Register&quot;)&#10;    class RegisterTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería registrar usuario exitosamente&quot;)&#10;        void deberiaRegistrarUsuario_CuandoLosDatosSonValidos() {&#10;            // PREPARAR: Configurar mock de UserService&#10;            when(userService.createUser(validRegisterRequest)).thenReturn(mockUserResponse);&#10;&#10;            // EJECUTAR: Registrar usuario&#10;            UserResponse result = authService.re(validRegisterRequest);&#10;&#10;            // ✅ VERIFICAR: Registro exitoso&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockUserResponse.getUsername(), result.getUsername());&#10;            assertEquals(mockUserResponse.getEmail(), result.getEmail());&#10;&#10;            verify(userService).createUser(validRegisterRequest);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería propagar BusinessException del UserService&quot;)&#10;        void deberiaPropagar_BusinessExceptionDelUserService() {&#10;            //  PREPARAR: UserService lanza excepción (ej: email duplicado)&#10;            when(userService.createUser(validRegisterRequest))&#10;                .thenThrow(new BusinessException(&quot;Email ya esta en uso&quot;));&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe propagar la excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validRegisterRequest),&#10;                &quot;Debería propagar BusinessException del UserService&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(userService).createUser(validRegisterRequest);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Register con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.createUser(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de registro son requeridos&quot;, exception.getMessage());&#10;            verify(userService, never()).createUser(any());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.request.LoginRequest;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.JwtResponse;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.security.JwtTokenProvider;&#10;import com.sordi.userManagement.service.AuthService;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para AuthService&#10; *&#10; * ESTRUCTURA:&#10; * - Tests de Login: Autenticación de usuarios&#10; * - Tests de Register: Registro de nuevos usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de AuthService&quot;)&#10;public class AuthServiceTest {&#10;&#10;    @Mock&#10;    private AuthenticationManager authenticationManager;&#10;&#10;    @Mock&#10;    private UserService userService;&#10;&#10;    @Mock&#10;    private JwtTokenProvider jwtTokenProvider;&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS&#10;    private LoginRequest validLoginRequest;&#10;    private CreateUserRequest validRegisterRequest;&#10;    private UserResponse mockUserResponse;&#10;    private Authentication mockAuthentication;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Configuración básica compartida&#10;        //Login&#10;        validLoginRequest = new LoginRequest();&#10;        validLoginRequest.setUsername(&quot;johndoe&quot;);&#10;        validLoginRequest.setPassword(&quot;password123&quot;);&#10;&#10;        // Register&#10;        validRegisterRequest = UserFixtures.createValidCreateUserRequest();&#10;        mockUserResponse = UserFixtures.createUserResponse();&#10;        mockAuthentication = mock(Authentication.class);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE LOGIN&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Login&quot;)&#10;    class LoginTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería autenticar usuario exitosamente con credenciales válidas&quot;)&#10;        void deberiaAutenticarUsuario_CuandoLasCredencialesSonValidas() {&#10;            //  PREPARAR: Configurar mocks para login exitoso&#10;            String expectedToken = &quot;jwt.token.aqui&quot;;&#10;            String username = &quot;johndoe&quot;;&#10;&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenReturn(mockAuthentication);&#10;            when(mockAuthentication.getName()).thenReturn(username); // Mock para getName()&#10;            when(jwtTokenProvider.generateToken(username))  // Pasar username, no Authentication&#10;                .thenReturn(expectedToken);&#10;&#10;            // ⚡ EJECUTAR: Intentar login&#10;            JwtResponse response = authService.login(validLoginRequest);&#10;&#10;            // ✅ VERIFICAR: Login exitoso&#10;            assertNotNull(response, &quot;La respuesta no debería ser null&quot;);&#10;            assertEquals(expectedToken, response.getAccessToken(), &quot;El token debería coincidir&quot;);&#10;            assertEquals(&quot;Bearer&quot;, response.getTokenType(), &quot;El tipo debería ser Bearer&quot;);&#10;&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider).generateToken(username); // Verificar con username&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción con credenciales incorrectas&quot;)&#10;        void deberiaLanzarExcepcion_CuandoLasCredencialesSonIncorrectas() {&#10;            // PREPARAR: Simular credenciales incorrectas&#10;            when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))&#10;                .thenThrow(new BadCredentialsException(&quot;Credenciales inválidas&quot;));&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe fallar la autenticación&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.login(validLoginRequest),&#10;                &quot;Debería lanzar BusinessException con credenciales incorrectas&quot;&#10;            );&#10;&#10;            assertTrue(exception.getMessage().contains(&quot;Credenciales inválidas&quot;));&#10;            verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Login con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.login(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de login son requeridos&quot;, exception.getMessage());&#10;            verify(authenticationManager, never()).authenticate(any());&#10;            verify(jwtTokenProvider, never()).generateToken(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE REGISTER&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método Register&quot;)&#10;    class RegisterTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería registrar usuario exitosamente&quot;)&#10;        void deberiaRegistrarUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mock de UserService&#10;            when(userService.createUser(validRegisterRequest)).thenReturn(mockUserResponse);&#10;&#10;            // ⚡ EJECUTAR: Registrar usuario&#10;            UserResponse result = authService.register(validRegisterRequest); // Corregido: era .re()&#10;&#10;            // ✅ VERIFICAR: Registro exitoso&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockUserResponse.getUsername(), result.getUsername());&#10;            assertEquals(mockUserResponse.getEmail(), result.getEmail());&#10;&#10;            verify(userService).createUser(validRegisterRequest);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería propagar BusinessException del UserService&quot;)&#10;        void deberiaPropagar_BusinessExceptionDelUserService() {&#10;            //  PREPARAR: UserService lanza excepción (ej: email duplicado)&#10;            when(userService.createUser(validRegisterRequest))&#10;                .thenThrow(new BusinessException(&quot;Email ya esta en uso&quot;));&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe propagar la excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; authService.register(validRegisterRequest), // Corregido: era userService.createUser()&#10;                &quot;Debería propagar BusinessException del UserService&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(userService).createUser(validRegisterRequest);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Register con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; authService.register(null), // Corregido: era userService.createUser()&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Datos de registro son requeridos&quot;, exception.getMessage());&#10;            verify(userService, never()).createUser(any());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/UserServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/sordi/userManagement/unit/service/UserServiceTest.java" />
              <option name="originalContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.Role;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para UserService&#10; *&#10; * ESTRUCTURA: Organizado con Nested Tests para mejor organización&#10; * - Tests de CreateUser: Todos los escenarios para creación de usuarios&#10; * - Tests de UpdateUser: Todos los escenarios para actualización de usuarios&#10; * - Tests de DeleteUser: Todos los escenarios para eliminación de usuarios&#10; * - Tests de GetUser: Todos los escenarios para consulta de usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de UserService&quot;)&#10;public class UserServiceTest {&#10;&#10;    //  MOCKS COMPARTIDOS para todas las clases de test anidadas&#10;    @Mock&#10;    private UserRepository userRepository;&#10;&#10;    @Mock&#10;    private UserMapper userMapper;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    //  SISTEMA BAJO PRUEBA&#10;    @InjectMocks&#10;    private UserService userService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS para todas las clases anidadas&#10;    private User mockUser;&#10;    private UserResponse mockResponse;&#10;&#10;    /**&#10;     *  CONFIGURACIÓN COMPARTIDA: Se ejecuta ANTES de cada test en cualquier clase anidada&#10;     */&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Solo datos verdaderamente compartidos&#10;        mockUser = UserFixtures.createBasicUser();&#10;&#10;        mockResponse = new UserResponse();&#10;        mockResponse.setId(1L);&#10;        mockResponse.setUsername(&quot;johndoe&quot;);&#10;        mockResponse.setEmail(&quot;john.doe@test.com&quot;);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE CREAR USUARIO&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método CreateUser&quot;)&#10;    class CreateUserTests {&#10;&#10;        //  DATOS ESPECÍFICOS para tests de CreateUser&#10;        private CreateUserRequest validRequest;&#10;&#10;        /**&#10;         *  CONFIGURACIÓN ESPECÍFICA para tests de CreateUser&#10;         */&#10;        @BeforeEach&#10;        void setUpCreateTests() {&#10;            // Crear request de usuario válido&#10;            validUserRequest = UserFixtures.createValidCreateUserRequest();&#10;        }&#10;&#10;        /**&#10;         *  Caso Feliz: Todas las validaciones pasan, usuario creado exitosamente&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería crear usuario exitosamente cuando todos los datos son válidos&quot;)&#10;        void deberiaCrearUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mocks para creación exitosa&#10;            // Simular que el username, email y DNI no existen&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(validUserRequest.getDni())).thenReturn(false);&#10;            // Simular que el usuario ya existe&#10;            when(userMapper.toEntity(validUserRequest)).thenReturn(mockUser);&#10;            when(passwordEncoder.encode(validUserRequest.getPassword())).thenReturn(&quot;$2a$10$hashedPassword&quot;);&#10;            when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockResponse);&#10;&#10;            //  EJECUTAR: Ejecutar el método bajo prueba&#10;            UserResponse response = userService.createUser(validUserRequest);&#10;&#10;            //  VERIFICAR: Verificar resultados e interacciones&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockResponse.getUsername(), response.getUsername(), &quot;El username debería coincidir&quot;);&#10;            assertEquals(mockResponse.getEmail(), response.getEmail(), &quot;El email debería coincidir&quot;);&#10;&#10;            // Verificar que todas las interacciones ocurrieron en el orden correcto&#10;            verify(userRepository).existsByUsername(validUserRequest.getUsername());&#10;            verify(userRepository).existsByEmail(validUserRequest.getEmail());&#10;            verify(userRepository).existsByDni(validUserRequest.getDni());&#10;            verify(passwordEncoder).encode(validUserRequest.getPassword());&#10;            verify(userRepository).save(any(User.class));&#10;            verify(userMapper).toResponse(mockUser);&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Email ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el email ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElEmailYaExiste() {&#10;            //  PREPARAR: Simular email existente&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el email existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;            verify(passwordEncoder, never()).encode(anyString());&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Username ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el username ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElUsernameYaExiste() {&#10;            //  PREPARAR: Simular username existente&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el username existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Nombre de usuario ya esta en uso&quot;, exception.getMessage());&#10;            verify(userRepository, never()).existsByEmail(anyString());&#10;            verify(userRepository, never()).existsByDni(anyString());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: DNI ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el DNI ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElDniYaExiste() {&#10;            //  PREPARAR: Username y email OK, pero DNI duplicado&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(validUserRequest.getDni())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el DNI existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;DNI existente&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Rol inválido proporcionado&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el rol es inválido&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElRolEsInvalido() {&#10;            //  PREPARAR: Crear request con rol inválido&#10;            CreateUserRequest invalidRoleRequest = UserFixtures.createValidCreateUserRequest();&#10;            invalidRoleRequest.setRole(&quot;ROL_INVALIDO&quot;);&#10;&#10;            when(userRepository.existsByUsername(invalidRoleRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(invalidRoleRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(invalidRoleRequest.getDni())).thenReturn(false);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(invalidRoleRequest),&#10;                &quot;Debería lanzar BusinessException cuando el rol es inválido&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Rol inválido. Solo se permiten: USER, ADMIN&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: Parámetro request nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con parámetro null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.createUser(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            // Verificar que no se llamó ningún método del repository&#10;            verify(userRepository, never()).existsByUsername(anyString());&#10;            verify(userRepository, never()).existsByEmail(anyString());&#10;            verify(userRepository, never()).existsByDni(anyString());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE ACTUALIZAR USUARIO&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot;✏️ Método UpdateUser&quot;)&#10;    class UpdateUserTests {&#10;&#10;        //  DATOS ESPECÍFICOS para tests de UpdateUser&#10;        private UpdateUserRequest validUpdateRequest;&#10;        private Long existingUserId;&#10;        private User existingUser;&#10;        private UserResponse updatedResponse;&#10;&#10;        /**&#10;         *  CONFIGURACIÓN ESPECÍFICA para tests de UpdateUser&#10;         */&#10;        @BeforeEach&#10;        void setUpUpdateTests() {&#10;            // Crear request de actualización válido&#10;            validUpdateRequest = UserFixtures.createValidUpdateUserRequest();&#10;&#10;            // Usuario existente que vamos a actualizar&#10;            existingUserId = 1L;&#10;            existingUser = UserFixtures.createBasicUser();&#10;            existingUser.setId(existingUserId);&#10;&#10;            // Respuesta esperada después de actualizar&#10;            updatedResponse = new UserResponse();&#10;            updatedResponse.setId(existingUserId);&#10;            updatedResponse.setFirstName(&quot;Jane&quot;); // Nombre actualizado&#10;            updatedResponse.setLastName(&quot;Smith&quot;);  // Apellido actualizado&#10;            updatedResponse.setEmail(&quot;jane.smith@test.com&quot;); // Email actualizado&#10;            updatedResponse.setUsername(&quot;johndoe&quot;); // Username se mantiene&#10;        }&#10;&#10;        /**&#10;         *  Caso Feliz: Actualización exitosa con datos válidos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería actualizar usuario exitosamente cuando los datos son válidos&quot;)&#10;        void deberiaActualizarUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mocks para actualización exitosa&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.save(any(User.class))).thenReturn(existingUser);&#10;            when(userMapper.toResponse(existingUser)).thenReturn(updatedResponse);&#10;&#10;            // ⚡ EJECUTAR: Ejecutar el método de actualización&#10;            UserResponse result = userService.updateUser(existingUserId, validUpdateRequest);&#10;&#10;            // ✅ VERIFICAR: Verificar resultados e interacciones&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(updatedResponse.getFirstName(), result.getFirstName(), &quot;El nombre debería estar actualizado&quot;);&#10;            assertEquals(updatedResponse.getEmail(), result.getEmail(), &quot;El email debería estar actualizado&quot;);&#10;&#10;            // Verificar que se llamaron los métodos correctos&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userMapper).updateEntity(existingUser, validUpdateRequest);&#10;            verify(userRepository).save(existingUser);&#10;            verify(userMapper).toResponse(existingUser);&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Usuario no encontrado&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;)&#10;        void deberiaLanzarResourceNotFoundException_CuandoElUsuarioNoExiste() {&#10;            //  PREPARAR: Simular usuario no encontrado&#10;            Long nonExistentUserId = 999L;&#10;            when(userRepository.findById(nonExistentUserId)).thenReturn(java.util.Optional.empty());&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            com.sordi.userManagement.exception.ResourceNotFoundException exception = assertThrows(&#10;                com.sordi.userManagement.exception.ResourceNotFoundException.class,&#10;                () -&gt; userService.updateUser(nonExistentUserId, validUpdateRequest),&#10;                &quot;Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Usuario con ID &quot; + nonExistentUserId + &quot; no encontrado&quot;, exception.getMessage());&#10;            verify(userRepository).findById(nonExistentUserId);&#10;            verify(userRepository, never()).save(any(User.class));&#10;            verify(userMapper, never()).updateEntity(any(User.class), any());&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Email duplicado en actualización&#10;         */&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el email ya existe en otro usuario&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElEmailYaExisteEnOtroUsuario() {&#10;            //  PREPARAR: Email que ya pertenece a otro usuario&#10;            String newEmail = &quot;existing@test.com&quot;;&#10;            validUpdateRequest.setEmail(newEmail);&#10;&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.existsByEmail(newEmail)).thenReturn(true); // Email ya existe&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.updateUser(existingUserId, validUpdateRequest),&#10;                &quot;Debería lanzar BusinessException cuando el email ya existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;El email ya está en uso por otro usuario&quot;, exception.getMessage());&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: Request nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.updateUser(existingUserId, null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario y datos de actualización son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: ID nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el ID es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElIdEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con ID null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.updateUser(null, validUpdateRequest),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el ID es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario y datos de actualización son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Específico: Actualizar solo email (campos opcionales)&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería actualizar solo el email cuando solo se proporciona email&quot;)&#10;        void deberiaActualizarSoloEmail_CuandoSoloSeProporcionaEmail() {&#10;            //  PREPARAR: Request con solo email nuevo&#10;            validUpdateRequest.setFirstName(null);&#10;            validUpdateRequest.setLastName(null);&#10;            validUpdateRequest.setEmail(&quot;nuevo@email.com&quot;);&#10;&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.existsByEmail(validUpdateRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.save(any(User.class))).thenReturn(existingUser);&#10;            when(userMapper.toResponse(existingUser)).thenReturn(updatedResponse);&#10;&#10;            // ⚡ EJECUTAR&#10;            UserResponse result = userService.updateUser(existingUserId, validUpdateRequest);&#10;&#10;            // ✅ VERIFICAR&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository).existsByEmail(validUpdateRequest.getEmail());&#10;            verify(userMapper).updateEntity(existingUser, validUpdateRequest);&#10;            verify(userRepository).save(existingUser);&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE ELIMINAR USUARIO (Marcadores)&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot;️ Método DeleteUser&quot;)&#10;    class DeleteUserTests {&#10;&#10;        private Long existingUserId;&#10;        private User existingUser;&#10;&#10;        private User existingUserAdmin;&#10;&#10;        /**&#10;         * CONFIGURACIÓN ESPECÍFICA para tests de DeleteUser&#10;         */&#10;        @BeforeEach&#10;        void setUpDeleteTests() {&#10;            // Simular que el usuario existe&#10;            existingUser = UserFixtures.createBasicUser();&#10;            existingUserId = existingUser.getId();&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería eliminar usuario cuando el usuario existe&quot;)&#10;        void deberiaEliminarUsuario_CuandoElUsuarioExiste() {&#10;            // PREPARAR: Configurar mock para usuario existente&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;&#10;            // ⚡ EJECUTAR: Llamar al método de eliminación&#10;            userService.deleteUser(existingUserId);&#10;&#10;            // VERIFICAR: Verificar que se llamaron los métodos correctos&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository).deleteById(existingUserId);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;)&#10;        void deberiaLanzarResourceNotFoundException_CuandoElUsuarioNoExiste() {&#10;            // PREPARAR: Simular usuario no encontrado&#10;            Long nonExistentUserId = 999L;&#10;            when(userRepository.findById(nonExistentUserId)).thenReturn(java.util.Optional.empty());&#10;&#10;            // EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            com.sordi.userManagement.exception.ResourceNotFoundException exception = assertThrows(&#10;                com.sordi.userManagement.exception.ResourceNotFoundException.class,&#10;                () -&gt; userService.deleteUser(nonExistentUserId),&#10;                &quot;Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Usuario con ID &quot; + nonExistentUserId + &quot; no encontrado&quot;, exception.getMessage());&#10;            verify(userRepository).findById(nonExistentUserId);&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el ID es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElIdEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Llamar con ID null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.deleteUser(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el ID es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario es requerido para eliminar&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción al intentar eliminar el último admin&quot;)&#10;        void deberiaLanzarExcepcion_AlIntentarEliminarElUltimoAdmin() {&#10;&#10;            // Test crítico para la lógica de negocio de protección del último admin&#10;            existingUserAdmin = UserFixtures.createAdminUser(); // ID 2L&#10;&#10;            when(userRepository.findById(existingUserAdmin.getId())).thenReturn(java.util.Optional.of(existingUserAdmin));&#10;            when(userRepository.countByRole(Role.ADMIN)).thenReturn(1L); // Simular que es el último admin&#10;&#10;            // EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            BusinessException exception = assertThrows(&#10;                    BusinessException.class,&#10;                    () -&gt; userService.deleteUser(existingUserAdmin.getId()),&#10;                    &quot;Debería lanzar BusinessException al intentar eliminar el último admin&quot;&#10;            );&#10;&#10;            assertEquals(&quot;No se puede eliminar el último administrador del sistema&quot;, exception.getMessage());&#10;&#10;            //Verificaciones de interacciones&#10;            verify(userRepository).findById(existingUserAdmin.getId());&#10;            verify(userRepository).countByRole(Role.ADMIN);&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE OBTENER USUARIO (Marcadores)&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Métodos GetUser&quot;)&#10;    class GetUserTests {&#10;        private User existingUser;&#10;        &#10;        @BeforeEach&#10;        void setUpGetTests() {&#10;            existingAdmin = UserFixtures.createAdminUser();&#10;        }&#10;        &#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería retornar usuario cuando el ID existe&quot;)&#10;        void deberiaRetornarUsuario_CuandoElIdExiste() {&#10;            when(userRepository.findById(mockUser.getId())).thenReturn(java.util.Optional.of(mockUser));&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockResponse);   &#10;            UserResponse response = userService.getUserById(mockUser.getId());&#10;            assertEquals(response, mockResponse);&#10;            verify(userRepository).findById(mockUser.getId());&#10;            verify(userMapper).toResponse(mockUser);&#10;            &#10;        &#10;            &#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción cuando el usuario no se encuentra&quot;)&#10;        void deberiaLanzarExcepcion_CuandoElUsuarioNoSeEncuentra() {&#10;            // TODO: Implementar tests de ResourceNotFoundException&#10;        }&#10;    }&#10;}&#10;            " />
              <option name="updatedContent" value="package com.sordi.userManagement.unit.service;&#10;&#10;import com.sordi.userManagement.exception.BusinessException;&#10;import com.sordi.userManagement.model.Role;&#10;import com.sordi.userManagement.model.User;&#10;import com.sordi.userManagement.model.dto.mapper.UserMapper;&#10;import com.sordi.userManagement.model.dto.request.CreateUserRequest;&#10;import com.sordi.userManagement.model.dto.request.UpdateUserRequest;&#10;import com.sordi.userManagement.model.dto.response.UserResponse;&#10;import com.sordi.userManagement.repository.UserRepository;&#10;import com.sordi.userManagement.service.UserService;&#10;import com.sordi.userManagement.fixtures.UserFixtures;&#10;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitarios para UserService&#10; *&#10; * ESTRUCTURA: Organizado con Nested Tests para mejor organización&#10; * - Tests de CreateUser: Todos los escenarios para creación de usuarios&#10; * - Tests de UpdateUser: Todos los escenarios para actualización de usuarios&#10; * - Tests de DeleteUser: Todos los escenarios para eliminación de usuarios&#10; * - Tests de GetUser: Todos los escenarios para consulta de usuarios&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot; Tests Unitarios de UserService&quot;)&#10;public class UserServiceTest {&#10;&#10;    //  MOCKS COMPARTIDOS para todas las clases de test anidadas&#10;    @Mock&#10;    private UserRepository userRepository;&#10;&#10;    @Mock&#10;    private UserMapper userMapper;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    //  SISTEMA BAJO PRUEBA&#10;    @InjectMocks&#10;    private UserService userService;&#10;&#10;    //  DATOS DE PRUEBA COMPARTIDOS para todas las clases anidadas&#10;    private User mockUser;&#10;    private UserResponse mockResponse;&#10;&#10;    /**&#10;     *  CONFIGURACIÓN COMPARTIDA: Se ejecuta ANTES de cada test en cualquier clase anidada&#10;     */&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Solo datos verdaderamente compartidos&#10;        mockUser = UserFixtures.createBasicUser();&#10;&#10;        mockResponse = new UserResponse();&#10;        mockResponse.setId(1L);&#10;        mockResponse.setUsername(&quot;johndoe&quot;);&#10;        mockResponse.setEmail(&quot;john.doe@test.com&quot;);&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE CREAR USUARIO&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Método CreateUser&quot;)&#10;    class CreateUserTests {&#10;&#10;        //  DATOS ESPECÍFICOS para tests de CreateUser&#10;        private CreateUserRequest validRequest;&#10;&#10;        /**&#10;         *  CONFIGURACIÓN ESPECÍFICA para tests de CreateUser&#10;         */&#10;        @BeforeEach&#10;        void setUpCreateTests() {&#10;            // Crear request de usuario válido&#10;            validUserRequest = UserFixtures.createValidCreateUserRequest();&#10;        }&#10;&#10;        /**&#10;         *  Caso Feliz: Todas las validaciones pasan, usuario creado exitosamente&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería crear usuario exitosamente cuando todos los datos son válidos&quot;)&#10;        void deberiaCrearUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mocks para creación exitosa&#10;            // Simular que el username, email y DNI no existen&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(validUserRequest.getDni())).thenReturn(false);&#10;            // Simular que el usuario ya existe&#10;            when(userMapper.toEntity(validUserRequest)).thenReturn(mockUser);&#10;            when(passwordEncoder.encode(validUserRequest.getPassword())).thenReturn(&quot;$2a$10$hashedPassword&quot;);&#10;            when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockResponse);&#10;&#10;            //  EJECUTAR: Ejecutar el método bajo prueba&#10;            UserResponse response = userService.createUser(validUserRequest);&#10;&#10;            //  VERIFICAR: Verificar resultados e interacciones&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(mockResponse.getUsername(), response.getUsername(), &quot;El username debería coincidir&quot;);&#10;            assertEquals(mockResponse.getEmail(), response.getEmail(), &quot;El email debería coincidir&quot;);&#10;&#10;            // Verificar que todas las interacciones ocurrieron en el orden correcto&#10;            verify(userRepository).existsByUsername(validUserRequest.getUsername());&#10;            verify(userRepository).existsByEmail(validUserRequest.getEmail());&#10;            verify(userRepository).existsByDni(validUserRequest.getDni());&#10;            verify(passwordEncoder).encode(validUserRequest.getPassword());&#10;            verify(userRepository).save(any(User.class));&#10;            verify(userMapper).toResponse(mockUser);&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Email ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el email ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElEmailYaExiste() {&#10;            //  PREPARAR: Simular email existente&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el email existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Email ya esta en uso&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;            verify(passwordEncoder, never()).encode(anyString());&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Username ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el username ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElUsernameYaExiste() {&#10;            //  PREPARAR: Simular username existente&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el username existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Nombre de usuario ya esta en uso&quot;, exception.getMessage());&#10;            verify(userRepository, never()).existsByEmail(anyString());&#10;            verify(userRepository, never()).existsByDni(anyString());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: DNI ya existe en la base de datos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el DNI ya existe&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElDniYaExiste() {&#10;            //  PREPARAR: Username y email OK, pero DNI duplicado&#10;            when(userRepository.existsByUsername(validUserRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(validUserRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(validUserRequest.getDni())).thenReturn(true);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(validUserRequest),&#10;                &quot;Debería lanzar BusinessException cuando el DNI existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;DNI existente&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Rol inválido proporcionado&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el rol es inválido&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElRolEsInvalido() {&#10;            //  PREPARAR: Crear request con rol inválido&#10;            CreateUserRequest invalidRoleRequest = UserFixtures.createValidCreateUserRequest();&#10;            invalidRoleRequest.setRole(&quot;ROL_INVALIDO&quot;);&#10;&#10;            when(userRepository.existsByUsername(invalidRoleRequest.getUsername())).thenReturn(false);&#10;            when(userRepository.existsByEmail(invalidRoleRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.existsByDni(invalidRoleRequest.getDni())).thenReturn(false);&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.createUser(invalidRoleRequest),&#10;                &quot;Debería lanzar BusinessException cuando el rol es inválido&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Rol inválido. Solo se permiten: USER, ADMIN&quot;, exception.getMessage());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: Parámetro request nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con parámetro null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.createUser(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            // Verificar que no se llamó ningún método del repository&#10;            verify(userRepository, never()).existsByUsername(anyString());&#10;            verify(userRepository, never()).existsByEmail(anyString());&#10;            verify(userRepository, never()).existsByDni(anyString());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE ACTUALIZAR USUARIO&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot;✏️ Método UpdateUser&quot;)&#10;    class UpdateUserTests {&#10;&#10;        //  DATOS ESPECÍFICOS para tests de UpdateUser&#10;        private UpdateUserRequest validUpdateRequest;&#10;        private Long existingUserId;&#10;        private User existingUser;&#10;        private UserResponse updatedResponse;&#10;&#10;        /**&#10;         *  CONFIGURACIÓN ESPECÍFICA para tests de UpdateUser&#10;         */&#10;        @BeforeEach&#10;        void setUpUpdateTests() {&#10;            // Crear request de actualización válido&#10;            validUpdateRequest = UserFixtures.createValidUpdateUserRequest();&#10;&#10;            // Usuario existente que vamos a actualizar&#10;            existingUserId = 1L;&#10;            existingUser = UserFixtures.createBasicUser();&#10;            existingUser.setId(existingUserId);&#10;&#10;            // Respuesta esperada después de actualizar&#10;            updatedResponse = new UserResponse();&#10;            updatedResponse.setId(existingUserId);&#10;            updatedResponse.setFirstName(&quot;Jane&quot;); // Nombre actualizado&#10;            updatedResponse.setLastName(&quot;Smith&quot;);  // Apellido actualizado&#10;            updatedResponse.setEmail(&quot;jane.smith@test.com&quot;); // Email actualizado&#10;            updatedResponse.setUsername(&quot;johndoe&quot;); // Username se mantiene&#10;        }&#10;&#10;        /**&#10;         *  Caso Feliz: Actualización exitosa con datos válidos&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería actualizar usuario exitosamente cuando los datos son válidos&quot;)&#10;        void deberiaActualizarUsuario_CuandoLosDatosSonValidos() {&#10;            //  PREPARAR: Configurar mocks para actualización exitosa&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.save(any(User.class))).thenReturn(existingUser);&#10;            when(userMapper.toResponse(existingUser)).thenReturn(updatedResponse);&#10;&#10;            // ⚡ EJECUTAR: Ejecutar el método de actualización&#10;            UserResponse result = userService.updateUser(existingUserId, validUpdateRequest);&#10;&#10;            // ✅ VERIFICAR: Verificar resultados e interacciones&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            assertEquals(updatedResponse.getFirstName(), result.getFirstName(), &quot;El nombre debería estar actualizado&quot;);&#10;            assertEquals(updatedResponse.getEmail(), result.getEmail(), &quot;El email debería estar actualizado&quot;);&#10;&#10;            // Verificar que se llamaron los métodos correctos&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userMapper).updateEntity(existingUser, validUpdateRequest);&#10;            verify(userRepository).save(existingUser);&#10;            verify(userMapper).toResponse(existingUser);&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Usuario no encontrado&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;)&#10;        void deberiaLanzarResourceNotFoundException_CuandoElUsuarioNoExiste() {&#10;            //  PREPARAR: Simular usuario no encontrado&#10;            Long nonExistentUserId = 999L;&#10;            when(userRepository.findById(nonExistentUserId)).thenReturn(java.util.Optional.empty());&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            com.sordi.userManagement.exception.ResourceNotFoundException exception = assertThrows(&#10;                com.sordi.userManagement.exception.ResourceNotFoundException.class,&#10;                () -&gt; userService.updateUser(nonExistentUserId, validUpdateRequest),&#10;                &quot;Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Usuario con ID &quot; + nonExistentUserId + &quot; no encontrado&quot;, exception.getMessage());&#10;            verify(userRepository).findById(nonExistentUserId);&#10;            verify(userRepository, never()).save(any(User.class));&#10;            verify(userMapper, never()).updateEntity(any(User.class), any());&#10;        }&#10;&#10;        /**&#10;         *  Caso de Error: Email duplicado en actualización&#10;         */&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar BusinessException cuando el email ya existe en otro usuario&quot;)&#10;        void deberiaLanzarBusinessException_CuandoElEmailYaExisteEnOtroUsuario() {&#10;            //  PREPARAR: Email que ya pertenece a otro usuario&#10;            String newEmail = &quot;existing@test.com&quot;;&#10;            validUpdateRequest.setEmail(newEmail);&#10;&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.existsByEmail(newEmail)).thenReturn(true); // Email ya existe&#10;&#10;            // ⚡ EJECUTAR Y VERIFICAR&#10;            BusinessException exception = assertThrows(&#10;                BusinessException.class,&#10;                () -&gt; userService.updateUser(existingUserId, validUpdateRequest),&#10;                &quot;Debería lanzar BusinessException cuando el email ya existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;El email ya está en uso por otro usuario&quot;, exception.getMessage());&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: Request nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el request es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElRequestEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con request null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.updateUser(existingUserId, null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el request es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario y datos de actualización son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Límite: ID nulo&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el ID es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElIdEsNull() {&#10;            // ⚡ EJECUTAR Y VERIFICAR: Llamar con ID null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.updateUser(null, validUpdateRequest),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el ID es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario y datos de actualización son requeridos&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).save(any(User.class));&#10;        }&#10;&#10;        /**&#10;         *  Caso Específico: Actualizar solo email (campos opcionales)&#10;         */&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería actualizar solo el email cuando solo se proporciona email&quot;)&#10;        void deberiaActualizarSoloEmail_CuandoSoloSeProporcionaEmail() {&#10;            //  PREPARAR: Request con solo email nuevo&#10;            validUpdateRequest.setFirstName(null);&#10;            validUpdateRequest.setLastName(null);&#10;            validUpdateRequest.setEmail(&quot;nuevo@email.com&quot;);&#10;&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;            when(userRepository.existsByEmail(validUpdateRequest.getEmail())).thenReturn(false);&#10;            when(userRepository.save(any(User.class))).thenReturn(existingUser);&#10;            when(userMapper.toResponse(existingUser)).thenReturn(updatedResponse);&#10;&#10;            // ⚡ EJECUTAR&#10;            UserResponse result = userService.updateUser(existingUserId, validUpdateRequest);&#10;&#10;            // ✅ VERIFICAR&#10;            assertNotNull(result, &quot;El resultado no debería ser null&quot;);&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository).existsByEmail(validUpdateRequest.getEmail());&#10;            verify(userMapper).updateEntity(existingUser, validUpdateRequest);&#10;            verify(userRepository).save(existingUser);&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE ELIMINAR USUARIO (Marcadores)&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot;️ Método DeleteUser&quot;)&#10;    class DeleteUserTests {&#10;&#10;        private Long existingUserId;&#10;        private User existingUser;&#10;&#10;        private User existingUserAdmin;&#10;&#10;        /**&#10;         * CONFIGURACIÓN ESPECÍFICA para tests de DeleteUser&#10;         */&#10;        @BeforeEach&#10;        void setUpDeleteTests() {&#10;            // Simular que el usuario existe&#10;            existingUser = UserFixtures.createBasicUser();&#10;            existingUserId = existingUser.getId();&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;✅ Debería eliminar usuario cuando el usuario existe&quot;)&#10;        void deberiaEliminarUsuario_CuandoElUsuarioExiste() {&#10;            // PREPARAR: Configurar mock para usuario existente&#10;            when(userRepository.findById(existingUserId)).thenReturn(java.util.Optional.of(existingUser));&#10;&#10;            // ⚡ EJECUTAR: Llamar al método de eliminación&#10;            userService.deleteUser(existingUserId);&#10;&#10;            // VERIFICAR: Verificar que se llamaron los métodos correctos&#10;            verify(userRepository).findById(existingUserId);&#10;            verify(userRepository).deleteById(existingUserId);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;)&#10;        void deberiaLanzarResourceNotFoundException_CuandoElUsuarioNoExiste() {&#10;            // PREPARAR: Simular usuario no encontrado&#10;            Long nonExistentUserId = 999L;&#10;            when(userRepository.findById(nonExistentUserId)).thenReturn(java.util.Optional.empty());&#10;&#10;            // EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            com.sordi.userManagement.exception.ResourceNotFoundException exception = assertThrows(&#10;                com.sordi.userManagement.exception.ResourceNotFoundException.class,&#10;                () -&gt; userService.deleteUser(nonExistentUserId),&#10;                &quot;Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;&#10;            );&#10;&#10;            assertEquals(&quot;Usuario con ID &quot; + nonExistentUserId + &quot; no encontrado&quot;, exception.getMessage());&#10;            verify(userRepository).findById(nonExistentUserId);&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar IllegalArgumentException cuando el ID es null&quot;)&#10;        void deberiaLanzarIllegalArgumentException_CuandoElIdEsNull() {&#10;            // EJECUTAR Y VERIFICAR: Llamar con ID null&#10;            IllegalArgumentException exception = assertThrows(&#10;                IllegalArgumentException.class,&#10;                () -&gt; userService.deleteUser(null),&#10;                &quot;Debería lanzar IllegalArgumentException cuando el ID es null&quot;&#10;            );&#10;&#10;            assertEquals(&quot;ID de usuario es requerido para eliminar&quot;, exception.getMessage());&#10;            verify(userRepository, never()).findById(any());&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción al intentar eliminar el último admin&quot;)&#10;        void deberiaLanzarExcepcion_AlIntentarEliminarElUltimoAdmin() {&#10;&#10;            // Test crítico para la lógica de negocio de protección del último admin&#10;            existingUserAdmin = UserFixtures.createAdminUser(); // ID 2L&#10;&#10;            when(userRepository.findById(existingUserAdmin.getId())).thenReturn(java.util.Optional.of(existingUserAdmin));&#10;            when(userRepository.countByRole(Role.ADMIN)).thenReturn(1L); // Simular que es el último admin&#10;&#10;            // EJECUTAR Y VERIFICAR: Verificar que se lance la excepción&#10;            BusinessException exception = assertThrows(&#10;                    BusinessException.class,&#10;                    () -&gt; userService.deleteUser(existingUserAdmin.getId()),&#10;                    &quot;Debería lanzar BusinessException al intentar eliminar el último admin&quot;&#10;            );&#10;&#10;            assertEquals(&quot;No se puede eliminar el último administrador del sistema&quot;, exception.getMessage());&#10;&#10;            //Verificaciones de interacciones&#10;            verify(userRepository).findById(existingUserAdmin.getId());&#10;            verify(userRepository).countByRole(Role.ADMIN);&#10;            verify(userRepository, never()).deleteById(any());&#10;        }&#10;    }&#10;&#10;    // ========================================&#10;    // TESTS DE OBTENER USUARIO (Marcadores)&#10;    // ========================================&#10;    @Nested&#10;    @DisplayName(&quot; Métodos GetUser&quot;)&#10;    class GetUserTests {&#10;        &#10;        @BeforeEach&#10;        void setUpGetTests() {&#10;            // No necesitas configuración específica aquí&#10;            // mockUser ya está disponible de la clase padre&#10;        }&#10;        &#10;        @Test&#10;        @DisplayName(&quot;✅ Debería retornar usuario cuando el ID existe&quot;)&#10;        void deberiaRetornarUsuario_CuandoElIdExiste() {&#10;            //  PREPARAR: Configurar mocks&#10;            when(userRepository.findById(mockUser.getId())).thenReturn(java.util.Optional.of(mockUser));&#10;            when(userMapper.toResponse(mockUser)).thenReturn(mockResponse);   &#10;            &#10;            // ⚡ EJECUTAR: Llamar al método&#10;            UserResponse response = userService.getUserById(mockUser.getId());&#10;            &#10;            // ✅ VERIFICAR: Resultados e interacciones&#10;            assertEquals(mockResponse, response); // Orden correcto: esperado, actual&#10;            verify(userRepository).findById(mockUser.getId()); // ✅ CORRECTO&#10;            verify(userMapper).toResponse(mockUser);&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;❌ Debería lanzar excepción cuando el usuario no se encuentra&quot;)&#10;        void deberiaLanzarExcepcion_CuandoElUsuarioNoSeEncuentra() {&#10;            //  PREPARAR: Simular usuario no encontrado&#10;            Long nonExistentId = 999L;&#10;            when(userRepository.findById(nonExistentId)).thenReturn(java.util.Optional.empty());&#10;            &#10;            // ⚡ EJECUTAR Y VERIFICAR: Debe lanzar excepción&#10;            com.sordi.userManagement.exception.ResourceNotFoundException exception = assertThrows(&#10;                com.sordi.userManagement.exception.ResourceNotFoundException.class,&#10;                () -&gt; userService.getUserById(nonExistentId),&#10;                &quot;Debería lanzar ResourceNotFoundException cuando el usuario no existe&quot;&#10;            );&#10;            &#10;            assertEquals(&quot;Usuario con ID &quot; + nonExistentId + &quot; no encontrado&quot;, exception.getMessage());&#10;            verify(userRepository).findById(nonExistentId);&#10;            verify(userMapper, never()).toResponse(any(User.class));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>